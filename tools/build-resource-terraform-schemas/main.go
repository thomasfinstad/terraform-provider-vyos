package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"

	// "github.com/gdexlab/go-render/render"

	"github.com/gdexlab/go-render/render"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/provider/vyos/schema/interfacedefinition"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	//"https://github.com/arl/gotypes"
)

/*
	type IfaceDef struct {
		Name   string
		Caller string
		Def    Attr
	}

	type Attr struct {
		Kind  string
		Type  string
		Name  string
		Value string
		Subs  []Attr
	}

	func (a *Attr) set_defaults() {
		if a.Kind == "" {
			a.Kind = "unset"
		}
		if a.Type == "" {
			a.Type = "unset"
		}
		if a.Name == "" {
			a.Name = "unset"
		}
		if a.Value == "" {
			a.Value = "unset"
		}
		if a.Subs == nil {
			a.Subs = []Attr{}
		}
	}
*/
func main() {
	args := os.Args[1:]
	inputXMLFilePath := args[0]
	outputDirectory := args[1]
	pkgName := args[2]

	_, thisFilename, _, ok := runtime.Caller(0)
	if !ok {
		panic("Did not get path info")
	}
	/*
		interfaceDefinitionPath := filepath.Join(filepath.Dir(thisFilename), "..", "..", ".build", "vyos", "interface-definitions", "lldp.xml")
		dat, err := ioutil.ReadFile(interfaceDefinitionPath)
	*/

	outputBaseName := strings.TrimSuffix(filepath.Base(inputXMLFilePath), filepath.Ext(inputXMLFilePath))
	outputFile := fmt.Sprintf("%s/autogen-%s.go", outputDirectory, outputBaseName)

	fmt.Printf("Creating: %s\n", outputFile)

	dat, err := os.ReadFile(inputXMLFilePath)
	die(err)

	interfaceDefinition := interfacedefinition.InterfaceDefinition{}
	err = xml.Unmarshal(dat, &interfaceDefinition)
	die(err)

	output := render.AsCode(interfaceDefinition)

	outputFormatted := []byte(output)

	// Remove nil values, example:
	// VersionAttr: (&interfacedefinition.VersionAttr)(nil)}
	outputFormatted = regexp.MustCompile(`\w+:[^:]+nil\),?`).ReplaceAll(outputFormatted, []byte(""))

	// Remove empty string values, example:
	// OwnerAttr:"",
	outputFormatted = regexp.MustCompile(`\w+:\s*"",?`).ReplaceAll(outputFormatted, []byte(""))

	// Add line breaks at each comma, attempt to avoid issues with commas in strings by requering formatting until next : and {
	// This is very imperfect and some formatter that would be able to split a single line mega struct would be preferable.
	outputFormatted = regexp.MustCompile(`,([\w\s]+:[^"]+{)`).ReplaceAll(outputFormatted, []byte(",\n$1"))

	file, err := os.Create(outputFile)
	if err != nil {
		return
	}
	defer file.Close()

	funcName := strings.ReplaceAll(cases.Lower(language.Norwegian).String(outputBaseName), "-", "")

	file.WriteString(
		fmt.Sprintf(`
			// Code generated by %s. DO NOT EDIT.

			package %s

			import (
				"encoding/xml"

				"github.com/thomasfinstad/terraform-provider-vyos/internal/provider/vyos/schema/interfacedefinition"
			)

			func %s() interfacedefinition.InterfaceDefinition {
				return `,
			thisFilename,
			pkgName,
			funcName,
		),
	)

	file.Write(outputFormatted)
	file.WriteString(`}`)

	/*
		for when we have time to create something more built to purpose

		attr, _ := subber(interfaceDefinition)
		def := IfaceDef{
			Caller: thisFilename,
			Name:   "llpd",
			Def:    attr,
		}

		t, err := template.New("template.tmpl").ParseFiles(
			filepath.Join(filepath.Dir(thisFilename),
				"template.tmpl",
			),
		)
		die(err)

		err = t.Execute(os.Stdout, def)
		die(err)

		fmt.Printf("%#v\n", def)
	*/
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

/*
for when we have time to create something more built to purpose

func subber(inputVal any) (Attr, bool) {
	var ret Attr
	ret.set_defaults()
	isNil := true

	v := reflect.ValueOf(inputVal)

	switch reflect.TypeOf(inputVal).Kind() {
	case reflect.Struct:
		fmt.Println("Struct: Number of fields:", v.NumField())

		for i := 0; i < v.NumField(); i++ {
			fmt.Printf("Idx:%d name:%s type:%s kind:%s value:%s\n",
				i,                          // idx
				v.Type().Field(i).Name,     // name
				v.Field(i).Type().String(), // type
				v.Field(i).Kind().String(), // kind
				v.Field(i).String(),        // value
			)

			if reflect.ValueOf(v).Kind() == reflect.Struct {

				if s, sIsNil := subber(v.Field(i).Interface()); !sIsNil {
					isNil = false
					ret.Subs = append(ret.Subs, s)
					ret.Kind = v.Field(i).Kind().String()
					ret.Name = v.Type().Field(i).Name
					ret.Type = "Struct"

				}
			} else {

				if !v.Field(i).IsNil() {
					isNil = false
					if s, sIsNil := subber(v.Field(i).Interface()); !sIsNil {
						ret.Subs = append(ret.Subs, s)
						ret.Kind = v.Field(i).Kind().String()
						ret.Name = v.Type().Field(i).Name
						ret.Type = "????"
					}
				} else {
					//fmt.Println("nil")
				}
			}
		}

	case reflect.Slice:
		fmt.Println("Slice: Number of fields:", v.Len())

		ret.Kind = v.Kind().String()
		ret.Name = v.Type().Name()
		ret.Type = "Slice"

		for i := 0; i < v.Len(); i++ {
			item := v.Index(i)

			if itemRet, itemIsnil := subber(item.Interface()); !itemIsnil {
				ret.Subs = append(ret.Subs, itemRet)
				isNil = false
			} else {
				//fmt.Printf("Idx:%d | nil\n", i)
			}

			// if item.Kind() == reflect.Struct {
			// 	v := reflect.Indirect(item)
			// 	for j := 0; j < v.NumField(); j++ {
			// 		fmt.Println(v.Type().Field(j).Name, v.Field(j).Interface())
			// 	}
			// }
		}

	case reflect.String:
		fmt.Println("String")

		ret.Kind = v.Kind().String()
		ret.Name = v.Type().Name()
		ret.Type = "String"

		if v.Interface() != nil && v.Interface() != "" {
			ret.Value = v.String()
			isNil = false
		} else {
			//fmt.Printf("nil\n")
		}

	case reflect.Ptr:
		fmt.Println("Ptr")

		ret.Kind = v.Kind().String()
		ret.Name = v.Type().Name()
		ret.Type = "Ptr"

		e := v.Elem()
		if e.IsValid() {
			if itemRet, itemIsnil := subber(e.Interface()); !itemIsnil {
				ret.Subs = append(ret.Subs, itemRet)
				isNil = false
			} else {
				//fmt.Printf("nil\n")
			}
		} else {
			//fmt.Printf("invalid\n")
		}

	default:
		panic(fmt.Sprintf("Currently unhandled: %s\n", reflect.ValueOf(inputVal).Kind().String()))
	}

	if !isNil {
		fmt.Println(ret.Name, "is", ret.Value, "with", len(ret.Subs), "kids")
	}
	return ret, isNil
}
*/
