{{define "package"}}
// Package {{.pkg}} code generated by {{.caller}}. DO NOT EDIT.
package {{.pkg}}
{{end}}

// Add all that are needed for everything combined,
// It will be cleaned up later by goimport
{{define "imports"}}
import (
	"context"
	"net/http"

	"golang.org/x/exp/maps"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/customtypes"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/client"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/helpers"

	{{if .}}
		// Extra Imports
		{{range .}}"{{.}}"{{end}}
	{{end}}
)
{{end}}

{{define "validate"}}
	// Ensure provider defined types fully satisfy framework interfaces.
	var _ resource.Resource = &{{.BaseNameG}}{}
	// var _ resource.ResourceWithImportState = &{{.BaseNameG}}{}
{{end}}

{{define "resource"}}
	// New{{.BaseNameCG}} method to return the example resource reference
	func New{{.BaseNameCG}}() resource.Resource {
		return &{{.BaseNameG}}{
			model: resourcemodel.{{.BaseNameCG}}{},
		}
	}

	// {{.BaseNameG}} defines the resource implementation.
	type {{.BaseNameG}} struct {
		ResourceName string
		client       *client.Client
		model        resourcemodel.{{.BaseNameCG}}
	}

	func (r *{{.BaseNameG}}) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
		// Prevent panic if the provider has not been configured.
		if req.ProviderData == nil {
			return
		}

		client, ok := req.ProviderData.(*client.Client)

		if !ok {
			resp.Diagnostics.AddError(
				"Unexpected Resource Configure Type",
				fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
			)

			return
		}

		r.client = client
	}
{{end}}

{{define "resource-model"}}
	// {{.BaseNameCG}} describes the resource data model.
	type {{.BaseNameCG}} struct {
		{{if not .Parent }}
			ID         types.String `tfsdk:"identifier"`
		{{end}}

		{{with .GetChildren }}
			// LeafNodes
			{{range .LeafNodes -}}
				{{.BaseNameCG}} {{.TfValue}} `tfsdk:"{{.BaseNameS}}" json:"{{.BaseName}},omitempty"`
			{{end}}
			// TagNodes
			{{range .TagNodes -}}
				{{.BaseNameCG}} {{.TfValue}} `tfsdk:"{{.BaseNameS}}" json:"{{.BaseName}},omitempty"`
			{{end}}
			// Nodes
			{{range .Nodes -}}
				{{.BaseNameCG}} {{.TfValue}} `tfsdk:"{{.BaseNameS}}" json:"{{.BaseName}},omitempty"`
			{{end}}
		{{end}}
	}

	{{/* func (m {{.BaseNameCG}}) GetVyosPath() (vyosPath []string) {
		return []string{
			{{range .VyosPath -}}
				"{{.}}",
			{{end}}
			m.ID.ValueString(),
		}
	}

	func (m {{.BaseNameCG}}) UnmarshalJSON(data []byte) error {

		var v []interface{}
		if err := json.Unmarshal(data, &v); err != nil {
			return err
		}

		b.Price, _ = v[0].(string)
		b.Size, _ = v[1].(string)
		b.NumOrders = int(v[2].(float64))

		return nil
	} */}}

	// ResourceAttributes generates the attributes for the resource at this level
	func (o {{.BaseNameCG}}) ResourceAttributes() map[string]schema.Attribute {
		return map[string]schema.Attribute{
			{{if not .Parent }}
				"identifier":         schema.StringAttribute{
						CustomType:          {{.TfType}}{},
						Required:            true,
						MarkdownDescription: `{{.Description}}`,
					},
			{{end}}
			{{with .GetChildren }}
				// LeafNodes
				{{range .LeafNodes }}
					"{{.BaseNameS}}": schema.StringAttribute{
						CustomType:          {{.TfType}}{},
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
						{{if .Default }}
						// Default:          stringdefault.StaticString({{.Default}}),
						Computed:            true,
						{{end}}
					},
				{{end}}

				// TagNodes
				{{range .TagNodes }}
					"{{.BaseNameS}}": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: {{.BaseNameCG}}{}.ResourceAttributes(),
						},
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
					},
				{{end}}
				// Nodes
				{{range .Nodes }}
					"{{.BaseNameS}}": schema.SingleNestedAttribute{
						Attributes: {{.BaseNameCG}}{}.ResourceAttributes(),
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
					},
				{{end}}
			{{end}}
		}
	}

	{{/* Recursively make resource model structs */}}
	{{/* {{with .GetChildren }}
		{{range .TagNodes -}}
			{{template "resource-model" . }}
		{{end}}
		{{range .Nodes -}}
			{{template "resource-model" . }}
		{{end}}
	{{end}} */}}
{{end}}

{{define "metadata"}}
// Metadata method to define the resource type name.
func (r {{.BaseNameG}}) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	r.ResourceName = req.ProviderTypeName + "_{{.AbsNameR}}"
	resp.TypeName = r.ResourceName
}
{{end}}

// TODO Add validators for map key
// Validators:          []validator.String(nil),
{{define "schema"}}
// Schema method to define the schema for any resource configuration, plan, and state data.
func (r {{.BaseNameG}}) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `{{.AncestorDescription}}`,
		Attributes: r.model.ResourceAttributes(),

		{{/* Attributes: map[string]schema.Attribute{
			"identifier": schema.StringAttribute{
			Required:            true,
			MarkdownDescription: `{{.Description}}`,

		},

			{{with .GetChildren }}
				{{range .TagNodes }} {{template "schema-tagnode" . }} {{end}}
				{{range .LeafNodes }} {{template "schema-leafnode" . }} {{end}}
				{{range .Nodes }} {{template "schema-node" . }} {{end}}
			{{end}}
		}, */}}
	}
}
{{end}}

{{/* // TODO handle non-string types
// TODO Recreate some of vyos validators for use in leafnodes
{{define "schema-leafnode"}}
"{{.BaseNameS}}": schema.StringAttribute{
	CustomType:          {{.TfType}}{},
	Optional:            true,
	MarkdownDescription: `{{.Description}}`,
	{{if .Default }}
	// Default:             stringdefault.StaticString({{.Default}}),
	Computed:            true,
	{{end}}
},
{{end}} */}}
{{/*
// TODO investigate if tagnode defaults can be handled
{{define "schema-tagnode"}}
"{{.BaseNameS}}": schema.MapNestedAttribute{
	NestedObject: schema.NestedAttributeObject{
		Attributes: map[string]schema.Attribute{
			{{with .GetChildren }}
				{{range .TagNodes }} {{template "schema-tagnode" . }} {{end}}
				{{range .LeafNodes }} {{template "schema-leafnode" . }} {{end}}
				{{range .Nodes }} {{template "schema-node" . }} {{end}}
			{{end}}
		},
	},
	Optional:            true,
	MarkdownDescription: `{{.Description}}`,
},
{{end}}

// TODO investigate if node defaults can be handled
{{define "schema-node"}}
"{{.BaseNameS}}": schema.SingleNestedAttribute{
	Attributes: map[string]schema.Attribute{
		{{with .GetChildren }}
			{{range .TagNodes }} {{template "schema-tagnode" . }} {{end}}
			{{range .LeafNodes }} {{template "schema-leafnode" . }} {{end}}
			{{range .Nodes }} {{template "schema-node" . }} {{end}}
		{{end}}
	},
	Optional:            true,
	MarkdownDescription: `{{.Description}}`,
},
{{end}} */}}

{{define "crud"}}
// Create method to define the logic which creates the resource and sets its initial Terraform state.
func (r {{.BaseNameG}}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	{{/* ctx = context.WithValue(ctx, "crud_func", "Create")

	var data *{{.BaseNameCG}}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	jsonString, err := json.Marshal(data)
	if err != nil {
		panic(err)
	}
	tflog.Error(ctx, "JSON", map[string]interface{}{"jsonString": string(jsonString)})

	panic("STOOOOOOP")

	// Create vyos api ops
	vyosOps := helpers.FromTerraformToVyos(ctx, data)
	for _, ops := range vyosOps {
		tflog.Error(ctx, "Vyos Ops generated", map[string]interface{}{"vyosOps": ops})
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	r.client.StageSet(ctx, vyosOps)
	response, err := r.client.CommitChanges(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
		return
	}
	if response != nil {
		tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
	}

	// Save ID into the Terraform state.
	data.ID = types.StringValue(data.ID.ValueString())

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) */}}
}

// Read method to define the logic which refreshes the Terraform state for the resource.
func (r {{.BaseNameG}}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	{{/* ctx = context.WithValue(ctx, "crud_func", "Read")

	var data *{{.BaseNameCG}}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	vyosPath := data.GetVyosPath()

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	response, err := r.client.Read(ctx, vyosPath)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
		return
	}
	if response != nil {
		tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
	}

	//data.VyosToTerraform(ctx, resp, response.(map[string]interface{}))

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...) */}}
}

// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
func (r {{.BaseNameG}}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	data := r.model

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
func (r {{.BaseNameG}}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	data := r.model

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }
}
{{end}}

{{define "unused"}}
// ImportState enables provider control over the ImportResourceState RPC.
func (r *ExampleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
{{end}}
