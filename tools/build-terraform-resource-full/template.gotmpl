{{define "package"}}
// Package {{.pkg}} code generated by {{.caller}}. DO NOT EDIT.
package {{.pkg}}
{{end}}

// Add all that are needed for everything combined,
// It will be cleaned up later by goimport
{{define "imports"}}
import (
	"context"
	"fmt"
	"net/http"
	"reflect"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/customtypes"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/client"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/helpers"

	{{if .}}
		// Extra Imports
		{{range .}}"{{.}}"{{end}}
	{{end}}
)
{{end}}

{{define "validate"}}
	// Ensure provider defined types fully satisfy framework interfaces.
	var _ resource.Resource = &{{.BaseNameG}}{}
	// var _ resource.ResourceWithImportState = &{{.BaseNameG}}{}
{{end}}

{{define "resource-tagnode-based-full"}}
	// New{{.BaseNameCG}} method to return the example resource reference
	func New{{.BaseNameCG}}() resource.Resource {
		return &{{.BaseNameG}}{
			model: resourcemodel.{{.BaseNameCG}}{},
		}
	}

	// {{.BaseNameG}} defines the resource implementation.
	type {{.BaseNameG}} struct {
		ResourceName string
		client       *client.Client
		model        resourcemodel.{{.BaseNameCG}}
	}

	func (r *{{.BaseNameG}}) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
		// Prevent panic if the provider has not been configured.
		if req.ProviderData == nil {
			return
		}

		client, ok := req.ProviderData.(*client.Client)

		if !ok {
			resp.Diagnostics.AddError(
				"Unexpected Resource Configure Type",
				fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
			)

			return
		}

		r.client = client
	}
{{end}}

{{define "resource-model-parent-hack"}}
	{{if .Parent}}
		{{template "resource-model-parent-hack" .Parent}}
	{{end}}
	{{if eq .NodeType "TagNode"}}
		ParentID{{.BaseNameCG}} any `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},parent-id"`
	{{end}}
{{end}}

// TODO look into using the json tags during unmarshalling,
// or use a custom MarshalVyos function with dedicated tag
{{define "resource-model"}}
	// {{.BaseNameCG}} describes the resource data model.
	type {{.BaseNameCG}} struct {
		{{if .IsBaseNode }}
			ID         types.String `tfsdk:"identifier" vyos:",self-id"`

			{{if .Parent}}
				{{template "resource-model-parent-hack" .Parent}}
			{{end}}
		{{end}}

		{{with .GetChildren }}
			// LeafNodes
			{{range .LeafNodes -}}
				Leaf{{.BaseNameCG}} 	{{if eq .ValueType "string" -}}
											types.String
										{{- else  if eq .ValueType "number" -}}
											NOT IMPLEMENTED
										{{- else if eq .ValueType "bool" -}}
											NOT IMPLEMENTED
										{{- else -}}
											UNKNOWN TYPE: {{.ValueType}}
										{{- end}} `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},omitempty"`
			{{end}}
			// TagNodes (Bools that show if child resources have been configured)
			{{range .TagNodes -}}
				ExistsTag{{.BaseNameCG}} bool `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},child"`
			{{end}}
			// Nodes
			{{range .Nodes -}}
				Node{{.BaseNameCG}} *{{.BaseNameCG}} `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},omitempty"`
			{{end}}
		{{end}}
	}

	{{if .IsBaseNode }}
		// GetVyosPath returns the list of strings to use to get to the correct vyos configuration
		func (o *{{.BaseNameCG}}) GetVyosPath() []string {
			return []string{
				{{range .AbsName}}
					"{{.}}",
				{{- end}}
				o.ID.ValueString(),
			}
		}
	{{end}}

	{{/* // AttributeTypes generates the attribute types for the resource at this level
	func (o {{.BaseNameCG}}) AttributeTypes() map[string]attr.Type {
		return map[string]attr.Type{
			{{with .GetChildren}}
				// Leafs
				{{range .LeafNodes -}}
					"{{.BaseNameS}}": 	{{if eq .ValueType "string" -}}
											types.StringType
										{{- else  if eq .ValueType "number" -}}
											NOT IMPLEMENTED
										{{- else if eq .ValueType "bool" -}}
											NOT IMPLEMENTED
										{{- else -}}
											UNKNOWN TYPE: {{.ValueType}}
										{{- end}},
				{{end}}
				// Tags
				{{range .TagNodes -}}
					"{{.BaseNameS}}": types.MapType{ElemType: types.ObjectType{AttrTypes: {{.BaseNameCG}}{}.AttributeTypes()} },
				{{end}}
				// Nodes
				{{range .Nodes -}}
					"{{.BaseNameS}}": types.ObjectType{AttrTypes: {{.BaseNameCG}}{}.AttributeTypes()},
				{{end}}
			{{end}}
		}
	} */}}

	// ResourceSchemaAttributes generates the schema attributes for the resource at this level
	func (o {{.BaseNameCG}}) ResourceSchemaAttributes() map[string]schema.Attribute {
		return map[string]schema.Attribute{
			{{if .IsBaseNode }}
				"identifier":         schema.StringAttribute{
						Required:            true,
						MarkdownDescription: `{{.Description}}`,
					},
			{{end}}
			{{with .GetChildren }}
				// LeafNodes
				{{range .LeafNodes }}
					"{{.BaseNameS}}": schema.StringAttribute{
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
						{{if .Default }}
						// Default:          stringdefault.StaticString({{.Default}}),
						Computed:            true,
						{{end}}
					},
				{{end}}

				{{/* // TagNodes
				{{range .TagNodes }}
					"{{.BaseNameS}}": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: {{.BaseNameCG}}{}.ResourceSchemaAttributes(),
						},
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
					},
				{{end}} */}}
				// Nodes
				{{range .Nodes }}
					"{{.BaseNameS}}": schema.SingleNestedAttribute{
						Attributes: {{.BaseNameCG}}{}.ResourceSchemaAttributes(),
						Optional:            true,
						MarkdownDescription: `{{.Description}}`,
					},
				{{end}}
			{{end}}
		}
	}

	// MarshalJSON returns json encoded string as bytes or error if marshalling did not go well
	func (o *{{.BaseNameCG}}) MarshalJSON() ([]byte, error) {
		jsonData := make(map[string]interface{})

		{{with .GetChildren }}
			// Leafs
			{{range .LeafNodes }}
				if !o.Leaf{{.BaseNameCG}}.IsNull() && !o.Leaf{{.BaseNameCG}}.IsUnknown() {
					jsonData["{{.BaseName}}"] = o.Leaf{{.BaseNameCG}}.ValueString()
				}
			{{end}}

			{{/* // Tags
			{{range .TagNodes }}
				if ! reflect.ValueOf(o.Tag{{.BaseNameCG}}).IsZero()  {
					subJSONStr, err := json.Marshal(o.Tag{{.BaseNameCG}})
					if err != nil {
						return nil, err
					}

					subData :=  make(map[string]interface{})
					err = json.Unmarshal(subJSONStr, &subData)
					if err != nil {
						return nil, err
					}
					jsonData["{{.BaseName}}"] = subData
				}
			{{end}} */}}

			// Nodes
			{{range .Nodes }}
				if ! reflect.ValueOf(o.Node{{.BaseNameCG}}).IsZero()  {
					subJSONStr, err := json.Marshal(o.Node{{.BaseNameCG}})
					if err != nil {
						return nil, err
					}

					subData :=  make(map[string]interface{})
					err = json.Unmarshal(subJSONStr, &subData)
					if err != nil {
						return nil, err
					}
					jsonData["{{.BaseName}}"] = subData
				}
			{{end}}
		{{end}}

		// Return compiled data
		ret, err := json.Marshal(jsonData)
		if err != nil {
			return nil, err
		}
		return ret, nil
	}

	// UnmarshalJSON unmarshals json byte array into this object
	func (o *{{.BaseNameCG}}) UnmarshalJSON(jsonStr []byte) error {
		jsonData := make(map[string]interface{})
		err := json.Unmarshal(jsonStr, &jsonData)
		if err != nil {
			return err
		}

		{{with .GetChildren }}
			// Leafs
			{{range .LeafNodes }}
				{{if eq .ValueType "string" -}}
					if value, ok := jsonData["{{.BaseName}}"]; ok {
						o.Leaf{{.BaseNameCG}} = basetypes.NewStringValue(value.(string))
					} else {
						o.Leaf{{.BaseNameCG}} = basetypes.NewStringNull()
					}
				{{- else  if eq .ValueType "number" -}}
					NUMBER NOT IMPLEMENTED
				{{- else if eq .ValueType "bool" -}}
					BOOL NOT IMPLEMENTED
				{{- else -}}
					UNKNOWN TYPE: {{.ValueType}}
				{{- end}}
			{{end}}

			{{/* // TagNodes
			{{range .TagNodes -}}
				if value, ok := jsonData["{{.BaseName}}"]; ok {
					subJSONStr, err := json.Marshal(value)
					if err != nil {
						return err
					}

					o.Tag{{.BaseNameCG}} = &map[string]{{.BaseNameCG}}{}

					err = json.Unmarshal(subJSONStr, o.Tag{{.BaseNameCG}})
					if err != nil {
						return err
					}
				}
			{{end}} */}}
			// Nodes
			{{range .Nodes -}}
				if value, ok := jsonData["{{.BaseName}}"]; ok {
					subJSONStr, err := json.Marshal(value)
					if err != nil {
						return err
					}

					o.Node{{.BaseNameCG}} = &{{.BaseNameCG}}{}

					err = json.Unmarshal(subJSONStr, o.Node{{.BaseNameCG}})
					if err != nil {
						return err
					}
				}
			{{end}}
		{{end}}

		return nil
	}
{{end}}

{{define "metadata"}}
// Metadata method to define the resource type name.
func (r {{.BaseNameG}}) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	r.ResourceName = req.ProviderTypeName + "_{{.AbsNameR}}"
	resp.TypeName = r.ResourceName
}
{{end}}

// TODO Add validators for map key
// Validators:          []validator.String(nil),
{{define "schema"}}
// Schema method to define the schema for any resource configuration, plan, and state data.
func (r {{.BaseNameG}}) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `{{.AncestorDescription}}`,
		Attributes: r.model.ResourceSchemaAttributes(),
	}
}
{{end}}

{{define "crud"}}
	// Create method to define the logic which creates the resource and sets its initial Terraform state.
	func (r {{.BaseNameG}}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
		data := r.model

		// Read Terraform plan data into the model
		resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

		if resp.Diagnostics.HasError() {
			return
		}

		jsonData, err := json.Marshal(data)
		if err != nil {
			resp.Diagnostics.AddError("Json Marshalling Error", fmt.Sprintf("%s", err))
			return
		}

		var vyosData map[string]interface{}
		err = json.Unmarshal(jsonData, &vyosData)
		if err != nil {
			resp.Diagnostics.AddError("Json Unmarshalling Error", fmt.Sprintf("%s", err))
			return
		}

		// Create vyos api ops
		vyosOps := helpers.GenerateVyosOps(ctx, data.GetVyosPath(), vyosData)
		tflog.Error(ctx, "Compiled vyos operations", map[string]interface{}{"vyosOps": vyosOps})

		// Stage changes
		r.client.StageSet(ctx, vyosOps)

		// Commit changes
		response, err := r.client.CommitChanges(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
			return
		}
		if response != nil {
			tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
		}

		// Save ID into the Terraform state.
		data.ID = types.StringValue(data.ID.ValueString())

		// Save data to Terraform state
		tflog.Trace(ctx, "resource created")
		tflog.Error(ctx, "Setting state", map[string]interface{}{"data": fmt.Sprintf("%#v", data)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	// Read method to define the logic which refreshes the Terraform state for the resource.
	func (r {{.BaseNameG}}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
		data := r.model

		// Read Terraform prior state data into the model
		resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

		if resp.Diagnostics.HasError() {
			return
		}

		vyosPath := data.GetVyosPath()

		// Fetch live state from Vyos
		response, err := r.client.Read(ctx, vyosPath)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
			return
		}
		if response != nil {
			tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
		}

		jsonStr, err := json.Marshal(response.(map[string]interface{}))
		err = json.Unmarshal(jsonStr, &r.model)
		if err != nil {
			resp.Diagnostics.AddError("Json Unmarshal Error", fmt.Sprintf("%s", err))
			return
		}

		// Save updated data into Terraform state
		tflog.Error(ctx, "Setting state", map[string]interface{}{"data": fmt.Sprintf("%#v", data)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
	func (r {{.BaseNameG}}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
		data := r.model

		// Read Terraform plan data into the model
		resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

		if resp.Diagnostics.HasError() {
			return
		}

		jsonData, err := json.Marshal(data)
		if err != nil {
			resp.Diagnostics.AddError("Json Marshalling Error", fmt.Sprintf("%s", err))
			return
		}

		var vyosData map[string]interface{}
		err = json.Unmarshal(jsonData, &vyosData)
		if err != nil {
			resp.Diagnostics.AddError("Json Unmarshalling Error", fmt.Sprintf("%s", err))
			return
		}

		// Create vyos api ops
		vyosOps := helpers.GenerateVyosOps(ctx, data.GetVyosPath(), vyosData)
		tflog.Error(ctx, "Compiled vyos operations", map[string]interface{}{"vyosOps": vyosOps})

		// Stage changes
		r.client.StageSet(ctx, vyosOps)

		// Commit changes
		response, err := r.client.CommitChanges(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
			return
		}
		if response != nil {
			tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
		}

		// Save ID into the Terraform state.
		data.ID = types.StringValue(data.ID.ValueString())

		// Save data to Terraform state
		tflog.Trace(ctx, "resource created")
		tflog.Error(ctx, "Setting state", map[string]interface{}{"data": fmt.Sprintf("%#v", data)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
	func (r {{.BaseNameG}}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
		data := r.model

		// Read Terraform prior state data into the model
		resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

		if resp.Diagnostics.HasError() {
			return
		}

		// If applicable, this is a great opportunity to initialize any necessary
		// provider client data and make a call using it.
		// httpResp, err := r.client.Do(httpReq)
		// if err != nil {
		//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
		//     return
		// }
	}
{{end}}

{{define "unused"}}
	// ImportState enables provider control over the ImportResourceState RPC.
	func (r *ExampleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
		resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	}
{{end}}
