{{define "package"}}
// Package {{.pkg}} code generated by {{.caller}}. DO NOT EDIT.
package {{.pkg}}
{{end}}

// Add all that are needed for everything combined,
// It will be cleaned up later by goimport
{{define "imports"}}
import (
	"context"
	"fmt"
	"net/http"
	"reflect"
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/thomasfinstad/terraform-provider-vyos/internal/client"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/helpers"

	{{if .}}
		// Extra Imports
		{{range .}}"{{.}}"{{end}}
	{{end}}
)
{{end}}

{{define "validate"}}
	// Ensure provider defined types fully satisfy framework interfaces.
	var _ resource.Resource = &{{.BaseNameG}}{}
	// var _ resource.ResourceWithImportState = &{{.BaseNameG}}{}
{{end}}

{{define "resource-tagnode-based-full"}}
	// New{{.BaseNameCG}} method to return the example resource reference
	func New{{.BaseNameCG}}() resource.Resource {
		return &{{.BaseNameG}}{
			model: &resourcemodel.{{.BaseNameCG}}{},
		}
	}

	// {{.BaseNameG}} defines the resource implementation.
	type {{.BaseNameG}} struct {
		client       *client.Client
		model        *resourcemodel.{{.BaseNameCG}}
	}

	// GetClient returns the vyos api client
	func (r *{{.BaseNameG}}) GetClient() *client.Client {
		return r.client
	}

	func (r *{{.BaseNameG}}) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
		// Prevent panic if the provider has not been configured.
		if req.ProviderData == nil {
			return
		}

		client, ok := req.ProviderData.(*client.Client)

		if !ok {
			resp.Diagnostics.AddError(
				"Unexpected Resource Configure Type",
				fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
			)

			return
		}

		r.client = client
	}
{{end}}

{{define "resource-model-parent-id-hack"}}
	{{if .Parent}}
		{{template "resource-model-parent-id-hack" .Parent}}
	{{end}}
	{{if eq .NodeType "TagNode"}}
		ParentID{{.BaseNameCG}} types.String `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},parent-id"`
	{{end}}
{{end}}

{{define "resource-model-parent-vyos-path-hack"}}
	{{- if .Parent}}
		{{template "resource-model-parent-vyos-path-hack" .Parent}}
	{{- end}}
	"{{.BaseName}}",
	{{- if eq .NodeType "TagNode"}}
		o.ParentID{{.BaseNameCG}}.ValueString(),
	{{- end}}
{{end}}

{{define "resource-model-parent-schema-hack"}}
	{{if .Parent}}
		{{template "resource-model-parent-schema-hack" .Parent}}
		{{- if eq .NodeType "TagNode" -}}
			"{{.BaseNameS}}_id":         schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `{{.Description}}`,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		{{end}}
	{{end}}
{{end}}

{{define "resource-model-schema-attrtype"}}
	{{if eq .ValueType "string" -}}
		schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			{{if .Default }}
				// Default:          stringdefault.StaticString({{.Default}}),
				Computed:            true,
			{{end}}
		},
	{{- else  if eq .ValueType "number" -}}
		schema.NumberAttribute{
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			{{if .Default }}
				// Default:          stringdefault.StaticString({{.Default}}),
				Computed:            true,
			{{end}}
		},
	{{- else if eq .ValueType "bool" -}}
		schema.BoolAttribute{
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			Default: booldefault.StaticBool(false),
			Computed:            true,
		},
	{{- else -}}
		UNKNOWN TYPE: {{.ValueType}}
	{{- end}}
{{end}}

{{define "resource-model-schema-attrtype-multi"}}
	{{if eq .ValueType "string" -}}
		schema.ListAttribute{
			ElementType: types.StringType,
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			{{if .Default }}
				// Default:          stringdefault.StaticString({{.Default}}),
				Computed:            true,
			{{end}}
		},
	{{- else  if eq .ValueType "number" -}}
		schema.ListAttribute{
			ElementType: types.NumberType,
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			{{if .Default }}
				// Default:          stringdefault.StaticString({{.Default}}),
				Computed:            true,
			{{end}}
		},
	{{- else if eq .ValueType "bool" -}}
		schema.ListAttribute{
			ElementType: types.BoolType,
			Optional:            true,
			MarkdownDescription: `{{.Description}}`,
			Default: booldefault.StaticBool(false),
			Computed:            true,
		},
	{{- else -}}
		UNKNOWN TYPE: {{.ValueType}}
	{{- end}}
{{end}}

{{define "resource-model"}}
	// {{.BaseNameCG}} describes the resource data model.
	type {{.BaseNameCG}} struct {
		{{if .IsBaseNode }}
			ID types.String `tfsdk:"id" vyos:"-,tfsdk-id"`

			SelfIdentifier	{{ if eq .ValueType "string" -}}
								types.String
							{{- else  if eq .ValueType "number" -}}
								types.Number
							{{- end -}}
			`tfsdk:"{{.BaseNameS}}_id" vyos:"-,self-id"`
			{{if .Parent}}
				{{template "resource-model-parent-id-hack" .Parent}}
			{{end}}


			{{with .GetChildren }}
				// LeafNodes
				{{range .LeafNodes -}}
					Leaf{{.BaseNameCG}} 	{{if .MultiValue -}}
												types.List
											{{- else if eq .ValueType "string" -}}
												types.String
											{{- else  if eq .ValueType "number" -}}
												types.Number
											{{- else if eq .ValueType "bool" -}}
												types.Bool
											{{- else -}}
												UNKNOWN TYPE: {{.ValueType}}
											{{- end}} `tfsdk:"{{.BaseNameSB}}" vyos:"{{.BaseName}},omitempty"`
				{{end}}
				// TagNodes (Bools that show if child resources have been configured)
				{{range .TagNodes -}}
					ExistsTag{{.BaseNameCG}} bool `tfsdk:"-" vyos:"{{.BaseName}},ignore,child"`
				{{end}}
				// Nodes
				{{range .Nodes -}}
					Node{{.BaseNameCG}} *{{.BaseNameCG}} `tfsdk:"{{.BaseNameSB}}" vyos:"{{.BaseName}},omitempty"`
				{{end}}
			{{end}}
		{{else}}
			{{with .GetChildren }}
				// LeafNodes
				{{range .LeafNodes -}}
					Leaf{{.BaseNameCG}} 	{{if .MultiValue -}}
												types.List
											{{- else if eq .ValueType "string" -}}
												types.String
											{{- else  if eq .ValueType "number" -}}
												types.Number
											{{- else if eq .ValueType "bool" -}}
												types.Bool
											{{- else -}}
												UNKNOWN TYPE: {{.ValueType}}
											{{- end}} `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},omitempty"`
				{{end}}
				// TagNodes (Bools that show if child resources have been configured)
				{{range .TagNodes -}}
					ExistsTag{{.BaseNameCG}} bool `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},ignore,child"`
				{{end}}
				// Nodes
				{{range .Nodes -}}
					Node{{.BaseNameCG}} *{{.BaseNameCG}} `tfsdk:"{{.BaseNameS}}" vyos:"{{.BaseName}},omitempty"`
				{{end}}
			{{end}}
		{{end}}
	}

	{{if .IsBaseNode }}
		// SetID configures the resource ID
		func (o *{{.BaseNameCG}}) SetID(id []string) {
			o.ID = basetypes.NewStringValue(strings.Join(id, "__"))
		}

		// GetVyosPath returns the list of strings to use to get to the correct vyos configuration
		func (o *{{.BaseNameCG}}) GetVyosPath() []string {
			if o.ID.ValueString() != "" {
				return strings.Split(o.ID.ValueString(), "__")
			}

			return []string{
				{{- if .Parent -}}
					{{template "resource-model-parent-vyos-path-hack" .Parent}}
				{{- end}}

				"{{.BaseName}}",
				{{if eq .ValueType "string" -}}
					o.SelfIdentifier.ValueString(),
				{{- else  if eq .ValueType "number" -}}
					o.SelfIdentifier.ValueBigFloat().String(),
				{{- else -}}
					UNSUPPORTED TYPE
				{{- end}}
			}
		}
	{{end}}

	// ResourceSchemaAttributes generates the schema attributes for the resource at this level
	func (o {{.BaseNameCG}}) ResourceSchemaAttributes() map[string]schema.Attribute {
		return map[string]schema.Attribute{
			{{if .IsBaseNode }}
				"id": schema.StringAttribute{
					Computed: true,
					MarkdownDescription: "Resource ID, full vyos path to the resource with each field seperated by dunder (`__`).",
				},
				"{{.BaseNameS}}_id": schema.StringAttribute{
					Required:            true,
					MarkdownDescription: `{{.Description}}`,
					PlanModifiers: []planmodifier.String{
						stringplanmodifier.RequiresReplace(),
					},
				},
				{{if .Parent}}
					{{template "resource-model-parent-schema-hack" .Parent}}
				{{end}}

				{{with .GetChildren }}
					// LeafNodes
					{{range .LeafNodes }}
						"{{.BaseNameSB}}": 	{{if .MultiValue -}}
												{{template "resource-model-schema-attrtype-multi" .}}
											{{else}}
												{{template "resource-model-schema-attrtype" .}}
											{{- end}}
					{{end}}

					// Nodes
					{{range .Nodes }}
						"{{.BaseNameSB}}": schema.SingleNestedAttribute{
							Attributes: {{.BaseNameCG}}{}.ResourceSchemaAttributes(),
							Optional:            true,
							MarkdownDescription: `{{.Description}}`,
						},
					{{end}}
				{{end}}
			{{else}}
				{{with .GetChildren }}
					// LeafNodes
					{{range .LeafNodes }}
						"{{.BaseNameS}}": 	{{if .MultiValue -}}
												{{template "resource-model-schema-attrtype-multi" .}}
											{{else}}
												{{template "resource-model-schema-attrtype" .}}
											{{- end}}
					{{end}}

					// Nodes
					{{range .Nodes }}
						"{{.BaseNameS}}": schema.SingleNestedAttribute{
							Attributes: {{.BaseNameCG}}{}.ResourceSchemaAttributes(),
							Optional:            true,
							MarkdownDescription: `{{.Description}}`,
						},
					{{end}}
				{{end}}
			{{end}}
		}
	}
{{end}}

{{define "metadata"}}
// Metadata method to define the resource type name.
func (r {{.BaseNameG}}) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{.AbsNameR}}"
}
{{end}}

// TODO Add validators for map key
// Validators:          []validator.String(nil),
{{define "schema"}}
// Schema method to define the schema for any resource configuration, plan, and state data.
func (r {{.BaseNameG}}) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `{{.AncestorDescription}}`,
		Attributes: r.model.ResourceSchemaAttributes(),
	}
}
{{end}}

// TODO attempt to move CRUD into helper file
// TODO add retry and timeout
// TODO Create: check if resource already exists and fail after timeout
// TODO Delete: check for children and fail delete after timeout if exists
{{define "crud"}}
	// Create method to define the logic which creates the resource and sets its initial Terraform state.
	func (r *{{.BaseNameG}}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
		tflog.Debug(ctx, "New Resource")
		tflog.Trace(ctx, "Fetching data model")
		planModel := r.model

		// Read Terraform plan data into the model
		tflog.Trace(ctx, "Fetching plan data")
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planModel)...)
		if resp.Diagnostics.HasError() {
			return
		}

		// Marshal resource model for vyos
		tflog.Trace(ctx, "Marshalling plan for VyOS")
		vyosData, err := helpers.MarshalVyos(ctx, planModel)
		if err != nil {
			resp.Diagnostics.AddError("API Marshalling error", fmt.Sprintf("%s", err))
			return
		}

		// Create vyos api ops
		tflog.Trace(ctx, "Formatting vyos operations")
		vyosOps := helpers.GenerateVyosOps(ctx, planModel.GetVyosPath(), vyosData)
		tflog.Trace(ctx, "Compiled vyos operations", map[string]interface{}{"vyosOps": vyosOps})

		// Stage changes
		tflog.Debug(ctx, "staging vyos changes api calls")
		r.GetClient().StageSet(ctx, vyosOps)

		// Commit changes
		tflog.Info(ctx, "committing vyos changes api calls")
		response, err := r.GetClient().CommitChanges(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", planModel.GetVyosPath(), err))
			return
		}
		if response != nil {
			tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
		}

		// Add ID to the resource model
		planModel.SetID(planModel.GetVyosPath())
		tflog.Info(ctx, "setting newly created resource id", map[string]interface{}{"vyos-path": planModel.GetVyosPath()})

		// Save data to Terraform state
		tflog.Trace(ctx, "resource created")
		tflog.Error(ctx, "Setting state", map[string]interface{}{"data": fmt.Sprintf("%#v", planModel)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &planModel)...)
	}

	// Read method to define the logic which refreshes the Terraform state for the resource.
	func (r *{{.BaseNameG}}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
		tflog.Debug(ctx, "Read Resource")
		tflog.Trace(ctx, "Fetching data model")
		stateModel := r.model

		// Read Terraform prior state data into the model
		tflog.Trace(ctx, "Fetching state data")
		resp.Diagnostics.Append(req.State.Get(ctx, &stateModel)...)
		if resp.Diagnostics.HasError() {
			return
		}

		// Fetch live state from Vyos
		tflog.Debug(ctx, "Fetching API data")
		response, err := r.GetClient().Read(ctx, stateModel.GetVyosPath())
		if err != nil {
			if err.Error() == "API ERROR: Configuration under specified path is empty\n" {
				tflog.Warn(ctx, "API Error: Empty resource", map[string]interface{}{"vyos-path": stateModel.GetVyosPath(), "error": err, "response": response})
			} else {
				tflog.Error(ctx, "API Error", map[string]interface{}{"vyos-path": stateModel.GetVyosPath(), "error": err, "response": response})
				resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read %s, got error: %s", stateModel.GetVyosPath(), err))
				return
			}
		} else {
			// Populate resource model
			if responseAssrt, ok := response.(map[string]any); ok {
				err := helpers.UnmarshalVyos(ctx, responseAssrt, stateModel)
				if err != nil {
					resp.Diagnostics.AddError("Vyos API response unmarshalling error", fmt.Sprintf("error=%#v", err))
					return
				}
			} else {
				resp.Diagnostics.AddError("Wrong API return type, expected map[string]any.", fmt.Sprintf("response=%#v", response))
				return
			}
		}

		// Save updated data into Terraform state
		tflog.Info(ctx, "Saving state")
		tflog.Trace(ctx, "Setting state to", map[string]interface{}{"data": fmt.Sprintf("%#v", stateModel)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &stateModel)...)
	}

	// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
	func (r *{{.BaseNameG}}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
		tflog.Debug(ctx, "Update Resource")
		tflog.Trace(ctx, "Fetching data model")
		planModel := r.model
		stateModel := r.model

		// Read Terraform plan data into the model
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planModel)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateModel)...)
		if resp.Diagnostics.HasError() {
			return
		}

		// Delete existing config
		stateVyosData, err := helpers.MarshalVyos(ctx, stateModel)
		if err != nil {
			resp.Diagnostics.AddError("API Marshalling error", fmt.Sprintf("%s", err))
			return
		}

		vyosOpsState := helpers.GenerateVyosOps(ctx, stateModel.GetVyosPath(), stateVyosData)
		tflog.Error(ctx, "Compiling vyos state operations", map[string]interface{}{"vyosOpsState": vyosOpsState})

		r.GetClient().StageDelete(ctx, vyosOpsState)

		// Create new config
		planVyosData, err := helpers.MarshalVyos(ctx, planModel)
		if err != nil {
			resp.Diagnostics.AddError("API Marshalling error", fmt.Sprintf("%s", err))
			return
		}

		vyosOpsPlan := helpers.GenerateVyosOps(ctx, planModel.GetVyosPath(), planVyosData)
		tflog.Error(ctx, "Compiling vyos plan operations", map[string]interface{}{"vyosOpsPlan": vyosOpsPlan})

		r.GetClient().StageSet(ctx, vyosOpsPlan)

		// Commit changes to api
		response, err := r.GetClient().CommitChanges(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", planModel.GetVyosPath(), err))
			return
		}
		if response != nil {
			tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
		}

		// Add ID to the resource model as plan fetching do not include it
		planModel.SetID(planModel.GetVyosPath())

		// Save data to Terraform state
		tflog.Trace(ctx, "resource updated")
		tflog.Error(ctx, "Setting state", map[string]interface{}{"data": fmt.Sprintf("%#v", planModel)})
		resp.Diagnostics.Append(resp.State.Set(ctx, &planModel)...)
	}

	// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
	func (r *{{.BaseNameG}}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
		tflog.Debug(ctx, "Delete Resource")
		tflog.Trace(ctx, "Fetching data model")
		stateModel := r.model

		// Read Terraform plan data into the model
		// resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateModel)...)
		if resp.Diagnostics.HasError() {
			return
		}

		// Delete resource
		vyosOps := [][]string{stateModel.GetVyosPath()}
		tflog.Error(ctx, "Compiling vyos operations", map[string]interface{}{"vyosOps": vyosOps})

		r.GetClient().StageDelete(ctx, vyosOps)

		// Commit changes to api
		response, err := r.GetClient().CommitChanges(ctx)
		if err != nil {
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", stateModel.GetVyosPath(), err))
			return
		}
		if response != nil {
			tflog.Error(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
			resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Got non-nil response from API: %s", response))
		}

		// Save data to Terraform state
		tflog.Info(ctx, "resource deleted")
	}
{{end}}

{{define "unused"}}
	// ImportState enables provider control over the ImportResourceState RPC.
	func (r *ExampleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
		resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	}
{{end}}
