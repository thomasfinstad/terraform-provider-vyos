package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"math"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/dstutil"
	"github.com/gdexlab/go-render/render"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/vyos/schema/interfacedefinition"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	args := os.Args[1:]
	inputXMLFilePath := args[0]
	outputDirectory := args[1]
	pkgName := args[2]

	_, thisFilename, _, ok := runtime.Caller(0)
	if !ok {
		panic("Did not get path info")
	}

	outputBaseName := strings.TrimSuffix(filepath.Base(inputXMLFilePath), filepath.Ext(inputXMLFilePath))
	outputFile := fmt.Sprintf("%s/autogen-%s.go", outputDirectory, outputBaseName)

	fmt.Printf("Creating: %s\n", outputFile)

	dat, err := os.ReadFile(inputXMLFilePath)
	die(err)

	topLevelInterface := interfacedefinition.InterfaceDefinition{}
	err = xml.Unmarshal(dat, &topLevelInterface)
	die(err)

	var dedup func(interfacedefinition.NodeParent)
	dedup = func(node interfacedefinition.NodeParent) {
		children := node.GetChildren()

		// Finding duplicate leaf nodes
		leafIdxToRemove := []int{}
		for idx1, l1 := range children.LeafNode {
			for idx2, l2 := range children.LeafNode {
				if idx1 != idx2 && l1.BaseName() == l2.BaseName() {
					idx := int(math.Min(float64(idx1), float64(idx2)))
					if sort.SearchInts(leafIdxToRemove, idx) == len(leafIdxToRemove) {
						leafIdxToRemove = append(leafIdxToRemove, idx)
						fmt.Printf("[%s] Has duplicate, marking idx: %d for removal\n", l1.BaseName(), idx)
					} else {
						fmt.Printf("[%s] Has duplicate, idx: %d already marked for removal\n", l1.BaseName(), idx)
					}
				}
			}
		}

		// Finding duplicate tag nodes
		tagIdxToRemove := []int{}
		for idx1, t1 := range children.TagNode {
			for idx2, t2 := range children.TagNode {
				if idx1 != idx2 && t1.BaseName() == t2.BaseName() {
					idx := int(math.Min(float64(idx1), float64(idx2)))
					if sort.SearchInts(tagIdxToRemove, idx) == len(tagIdxToRemove) {
						tagIdxToRemove = append(tagIdxToRemove, idx)
						fmt.Printf("[%s] Has duplicate, marking idx: %d for removal\n", t1.BaseName(), idx)
					} else {
						fmt.Printf("[%s] Has duplicate, idx: %d already marked for removal\n", t1.BaseName(), idx)
					}
				}
			}
		}

		// Finding duplicate leaf nodes
		nodeIdxToRemove := []int{}
		for idx1, n1 := range children.Node {
			for idx2, n2 := range children.Node {
				if idx1 != idx2 && n1.BaseName() == n2.BaseName() {
					idx := int(math.Min(float64(idx1), float64(idx2)))
					if sort.SearchInts(nodeIdxToRemove, idx) == len(nodeIdxToRemove) {
						nodeIdxToRemove = append(nodeIdxToRemove, idx)
						fmt.Printf("[%s] Has duplicate, marking idx: %d for removal\n", n1.BaseName(), idx)
					} else {
						fmt.Printf("[%s] Has duplicate, idx: %d already marked for removal\n", n1.BaseName(), idx)
					}
				}
			}
		}

		// Removing duplicates
		sort.Sort(sort.Reverse(sort.IntSlice(leafIdxToRemove)))
		for _, idx := range leafIdxToRemove {
			fmt.Printf("[%s] idx: %d Removing leaf...\n", children.LeafNode[idx].BaseName(), idx)
			children.LeafNode = append(children.LeafNode[:idx], children.LeafNode[idx+1:]...)
		}

		sort.Sort(sort.Reverse(sort.IntSlice(tagIdxToRemove)))
		for _, idx := range tagIdxToRemove {
			fmt.Printf("[%s] idx: %d Removing tag...\n", children.TagNode[idx].BaseName(), idx)
			children.TagNode = append(children.TagNode[:idx], children.TagNode[idx+1:]...)
		}

		sort.Sort(sort.Reverse(sort.IntSlice(nodeIdxToRemove)))
		for _, idx := range nodeIdxToRemove {
			fmt.Printf("[%s] idx: %d Removing node...\n", children.Node[idx].BaseName(), idx)
			children.Node = append(children.Node[:idx], children.Node[idx+1:]...)
		}

		// Recurse
		for _, t := range children.TagNode {
			dedup(t)
		}

		for _, n := range children.Node {
			dedup(n)
		}
	}

	rootNode, err := topLevelInterface.GetRootNode()
	die(err)
	dedup(rootNode)

	output := render.AsCode(topLevelInterface)

	outputFormatted := []byte(output)

	// Remove nil values, example:
	// VersionAttr: (&interfacedefinition.VersionAttr)(nil)}
	outputFormatted = regexp.MustCompile(`\w+:[^:]+nil\),?`).ReplaceAll(outputFormatted, []byte(""))

	// Remove empty string values, example:
	// OwnerAttr:"",
	outputFormatted = regexp.MustCompile(`\w+:\s*"",?`).ReplaceAll(outputFormatted, []byte(""))

	file, err := os.Create(outputFile)
	if err != nil {
		return
	}
	defer file.Close()

	funcName := strings.ReplaceAll(cases.Lower(language.Norwegian).String(outputBaseName), "-", "")

	outputBase := fmt.Sprintf(`
			// Code generated by %s. DO NOT EDIT.

			package %s

			import (
				"encoding/xml"

				"github.com/thomasfinstad/terraform-provider-vyos/internal/vyos/schema/interfacedefinition"
			)

			func %s() interfacedefinition.InterfaceDefinition {
				return %s
			}
			`,
		thisFilename,
		pkgName,
		funcName,
		outputFormatted,
	)

	// Use DST to add linebreaks in generated code for readability
	fset, err := decorator.Parse(outputBase)
	if err != nil {
		panic(err)
	}

	dstutil.Apply(fset, nil, func(c *dstutil.Cursor) bool {
		n := c.Node()

		switch x := n.(type) {
		case *dst.KeyValueExpr:
			x.Decorations().Before = dst.NewLine

		case *dst.Package:
			fmt.Println("Skipping package node")
		}

		return true
	})

	err = decorator.Fprint(file, fset)
	die(err)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
