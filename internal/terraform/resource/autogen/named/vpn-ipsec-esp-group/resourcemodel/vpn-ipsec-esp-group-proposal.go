// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"encoding/json"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// VpnIPsecEspGroupProposal describes the resource data model.
type VpnIPsecEspGroupProposal struct {
	// LeafNodes
	LeafVpnIPsecEspGroupProposalEncryption types.String `tfsdk:"encryption" json:"encryption,omitempty"`
	LeafVpnIPsecEspGroupProposalHash       types.String `tfsdk:"hash" json:"hash,omitempty"`

	// TagNodes

	// Nodes
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o VpnIPsecEspGroupProposal) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		// LeafNodes

		"encryption": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Encryption algorithm

|  Format  |  Description  |
|----------|---------------|
|  null  |  Null encryption  |
|  aes128  |  128 bit AES-CBC  |
|  aes192  |  192 bit AES-CBC  |
|  aes256  |  256 bit AES-CBC  |
|  aes128ctr  |  128 bit AES-COUNTER  |
|  aes192ctr  |  192 bit AES-COUNTER  |
|  aes256ctr  |  256 bit AES-COUNTER  |
|  aes128ccm64  |  128 bit AES-CCM with 64 bit ICV  |
|  aes192ccm64  |  192 bit AES-CCM with 64 bit ICV  |
|  aes256ccm64  |  256 bit AES-CCM with 64 bit ICV  |
|  aes128ccm96  |  128 bit AES-CCM with 96 bit ICV  |
|  aes192ccm96  |  192 bit AES-CCM with 96 bit ICV  |
|  aes256ccm96  |  256 bit AES-CCM with 96 bit ICV  |
|  aes128ccm128  |  128 bit AES-CCM with 128 bit ICV  |
|  aes192ccm128  |  192 bit AES-CCM with 128 bit IC  |
|  aes256ccm128  |  256 bit AES-CCM with 128 bit ICV  |
|  aes128gcm64  |  128 bit AES-GCM with 64 bit ICV  |
|  aes192gcm64  |  192 bit AES-GCM with 64 bit ICV  |
|  aes256gcm64  |  256 bit AES-GCM with 64 bit ICV  |
|  aes128gcm96  |  128 bit AES-GCM with 96 bit ICV  |
|  aes192gcm96  |  192 bit AES-GCM with 96 bit ICV  |
|  aes256gcm96  |  256 bit AES-GCM with 96 bit ICV  |
|  aes128gcm128  |  128 bit AES-GCM with 128 bit ICV  |
|  aes192gcm128  |  192 bit AES-GCM with 128 bit ICV  |
|  aes256gcm128  |  256 bit AES-GCM with 128 bit ICV  |
|  aes128gmac  |  Null encryption with 128 bit AES-GMAC  |
|  aes192gmac  |  Null encryption with 192 bit AES-GMAC  |
|  aes256gmac  |  Null encryption with 256 bit AES-GMAC  |
|  3des  |  168 bit 3DES-EDE-CBC  |
|  blowfish128  |  128 bit Blowfish-CBC  |
|  blowfish192  |  192 bit Blowfish-CBC  |
|  blowfish256  |  256 bit Blowfish-CBC  |
|  camellia128  |  128 bit Camellia-CBC  |
|  camellia192  |  192 bit Camellia-CBC  |
|  camellia256  |  256 bit Camellia-CBC  |
|  camellia128ctr  |  128 bit Camellia-COUNTER  |
|  camellia192ctr  |  192 bit Camellia-COUNTER  |
|  camellia256ctr  |  256 bit Camellia-COUNTER  |
|  camellia128ccm64  |  128 bit Camellia-CCM with 64 bit ICV  |
|  camellia192ccm64  |  192 bit Camellia-CCM with 64 bit ICV  |
|  camellia256ccm64  |  256 bit Camellia-CCM with 64 bit ICV  |
|  camellia128ccm96  |  128 bit Camellia-CCM with 96 bit ICV  |
|  camellia192ccm96  |  192 bit Camellia-CCM with 96 bit ICV  |
|  camellia256ccm96  |  256 bit Camellia-CCM with 96 bit ICV  |
|  camellia128ccm128  |  128 bit Camellia-CCM with 128 bit ICV  |
|  camellia192ccm128  |  192 bit Camellia-CCM with 128 bit ICV  |
|  camellia256ccm128  |  256 bit Camellia-CCM with 128 bit ICV  |
|  serpent128  |  128 bit Serpent-CBC  |
|  serpent192  |  192 bit Serpent-CBC  |
|  serpent256  |  256 bit Serpent-CBC  |
|  twofish128  |  128 bit Twofish-CBC  |
|  twofish192  |  192 bit Twofish-CBC  |
|  twofish256  |  256 bit Twofish-CBC  |
|  cast128  |  128 bit CAST-CBC  |
|  chacha20poly1305  |  256 bit ChaCha20/Poly1305 with 128 bit ICV  |

`,

			// Default:          stringdefault.StaticString(`aes128`),
			Computed: true,
		},

		"hash": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Hash algorithm

|  Format  |  Description  |
|----------|---------------|
|  md5  |  MD5 HMAC  |
|  md5_128  |  MD5_128 HMAC  |
|  sha1  |  SHA1 HMAC  |
|  sha1_160  |  SHA1_160 HMAC  |
|  sha256  |  SHA2_256_128 HMAC  |
|  sha256_96  |  SHA2_256_96 HMAC  |
|  sha384  |  SHA2_384_192 HMAC  |
|  sha512  |  SHA2_512_256 HMAC  |
|  aesxcbc  |  AES XCBC  |
|  aescmac  |  AES CMAC  |
|  aes128gmac  |  128-bit AES-GMAC  |
|  aes192gmac  |  192-bit AES-GMAC  |
|  aes256gmac  |  256-bit AES-GMAC  |

`,

			// Default:          stringdefault.StaticString(`sha1`),
			Computed: true,
		},

		// TagNodes

		// Nodes

	}
}

// MarshalJSON returns json encoded string as bytes or error if marshalling did not go well
func (o *VpnIPsecEspGroupProposal) MarshalJSON() ([]byte, error) {
	jsonData := make(map[string]interface{})

	// Leafs

	if !o.LeafVpnIPsecEspGroupProposalEncryption.IsNull() && !o.LeafVpnIPsecEspGroupProposalEncryption.IsUnknown() {
		jsonData["encryption"] = o.LeafVpnIPsecEspGroupProposalEncryption.ValueString()
	}

	if !o.LeafVpnIPsecEspGroupProposalHash.IsNull() && !o.LeafVpnIPsecEspGroupProposalHash.IsUnknown() {
		jsonData["hash"] = o.LeafVpnIPsecEspGroupProposalHash.ValueString()
	}

	// Tags

	// Nodes

	// Return compiled data
	ret, err := json.Marshal(jsonData)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

// UnmarshalJSON unmarshals json byte array into this object
func (o *VpnIPsecEspGroupProposal) UnmarshalJSON(jsonStr []byte) error {
	jsonData := make(map[string]interface{})
	err := json.Unmarshal(jsonStr, &jsonData)
	if err != nil {
		return err
	}

	// Leafs

	if value, ok := jsonData["encryption"]; ok {
		o.LeafVpnIPsecEspGroupProposalEncryption = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafVpnIPsecEspGroupProposalEncryption = basetypes.NewStringNull()
	}

	if value, ok := jsonData["hash"]; ok {
		o.LeafVpnIPsecEspGroupProposalHash = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafVpnIPsecEspGroupProposalHash = basetypes.NewStringNull()
	}

	// Tags

	// Nodes

	return nil
}
