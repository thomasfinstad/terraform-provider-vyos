// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// PolicyRouteMapRuleMatch describes the resource data model.
type PolicyRouteMapRuleMatch struct {
	// LeafNodes
	LeafPolicyRouteMapRuleMatchAsPath          types.String `tfsdk:"as_path"`
	LeafPolicyRouteMapRuleMatchExtcommunity    types.String `tfsdk:"extcommunity"`
	LeafPolicyRouteMapRuleMatchInterface       types.String `tfsdk:"interface"`
	LeafPolicyRouteMapRuleMatchLocalPreference types.String `tfsdk:"local_preference"`
	LeafPolicyRouteMapRuleMatchMetric          types.String `tfsdk:"metric"`
	LeafPolicyRouteMapRuleMatchOrigin          types.String `tfsdk:"origin"`
	LeafPolicyRouteMapRuleMatchPeer            types.String `tfsdk:"peer"`
	LeafPolicyRouteMapRuleMatchRpki            types.String `tfsdk:"rpki"`
	LeafPolicyRouteMapRuleMatchTag             types.String `tfsdk:"tag"`

	// TagNodes

	// Nodes
	NodePolicyRouteMapRuleMatchCommunity      types.Object `tfsdk:"community"`
	NodePolicyRouteMapRuleMatchEvpn           types.Object `tfsdk:"evpn"`
	NodePolicyRouteMapRuleMatchIP             types.Object `tfsdk:"ip"`
	NodePolicyRouteMapRuleMatchIPvsix         types.Object `tfsdk:"ipv6"`
	NodePolicyRouteMapRuleMatchLargeCommunity types.Object `tfsdk:"large_community"`
}

// TerraformToVyos converts terraform data to vyos data
func (o *PolicyRouteMapRuleMatch) TerraformToVyos(ctx context.Context, diags *diag.Diagnostics) map[string]interface{} {
	tflog.Error(ctx, "TerraformToVyos", map[string]interface{}{"Path": []string{"policy", "route-map", "rule", "match"}})

	vyosData := make(map[string]interface{})

	// Leafs
	if !(o.LeafPolicyRouteMapRuleMatchAsPath.IsNull() || o.LeafPolicyRouteMapRuleMatchAsPath.IsUnknown()) {
		vyosData["as-path"] = o.LeafPolicyRouteMapRuleMatchAsPath.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchExtcommunity.IsNull() || o.LeafPolicyRouteMapRuleMatchExtcommunity.IsUnknown()) {
		vyosData["extcommunity"] = o.LeafPolicyRouteMapRuleMatchExtcommunity.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchInterface.IsNull() || o.LeafPolicyRouteMapRuleMatchInterface.IsUnknown()) {
		vyosData["interface"] = o.LeafPolicyRouteMapRuleMatchInterface.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchLocalPreference.IsNull() || o.LeafPolicyRouteMapRuleMatchLocalPreference.IsUnknown()) {
		vyosData["local-preference"] = o.LeafPolicyRouteMapRuleMatchLocalPreference.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchMetric.IsNull() || o.LeafPolicyRouteMapRuleMatchMetric.IsUnknown()) {
		vyosData["metric"] = o.LeafPolicyRouteMapRuleMatchMetric.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchOrigin.IsNull() || o.LeafPolicyRouteMapRuleMatchOrigin.IsUnknown()) {
		vyosData["origin"] = o.LeafPolicyRouteMapRuleMatchOrigin.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchPeer.IsNull() || o.LeafPolicyRouteMapRuleMatchPeer.IsUnknown()) {
		vyosData["peer"] = o.LeafPolicyRouteMapRuleMatchPeer.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchRpki.IsNull() || o.LeafPolicyRouteMapRuleMatchRpki.IsUnknown()) {
		vyosData["rpki"] = o.LeafPolicyRouteMapRuleMatchRpki.ValueString()
	}
	if !(o.LeafPolicyRouteMapRuleMatchTag.IsNull() || o.LeafPolicyRouteMapRuleMatchTag.IsUnknown()) {
		vyosData["tag"] = o.LeafPolicyRouteMapRuleMatchTag.ValueString()
	}

	// Tags

	// Nodes
	if !(o.NodePolicyRouteMapRuleMatchCommunity.IsNull() || o.NodePolicyRouteMapRuleMatchCommunity.IsUnknown()) {
		var subModel PolicyRouteMapRuleMatchCommunity
		diags.Append(o.NodePolicyRouteMapRuleMatchCommunity.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["community"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodePolicyRouteMapRuleMatchEvpn.IsNull() || o.NodePolicyRouteMapRuleMatchEvpn.IsUnknown()) {
		var subModel PolicyRouteMapRuleMatchEvpn
		diags.Append(o.NodePolicyRouteMapRuleMatchEvpn.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["evpn"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodePolicyRouteMapRuleMatchIP.IsNull() || o.NodePolicyRouteMapRuleMatchIP.IsUnknown()) {
		var subModel PolicyRouteMapRuleMatchIP
		diags.Append(o.NodePolicyRouteMapRuleMatchIP.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ip"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodePolicyRouteMapRuleMatchIPvsix.IsNull() || o.NodePolicyRouteMapRuleMatchIPvsix.IsUnknown()) {
		var subModel PolicyRouteMapRuleMatchIPvsix
		diags.Append(o.NodePolicyRouteMapRuleMatchIPvsix.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ipv6"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodePolicyRouteMapRuleMatchLargeCommunity.IsNull() || o.NodePolicyRouteMapRuleMatchLargeCommunity.IsUnknown()) {
		var subModel PolicyRouteMapRuleMatchLargeCommunity
		diags.Append(o.NodePolicyRouteMapRuleMatchLargeCommunity.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["large-community"] = subModel.TerraformToVyos(ctx, diags)
	}

	// Return compiled data
	return vyosData
}

// VyosToTerraform converts vyos data to terraform data
func (o *PolicyRouteMapRuleMatch) VyosToTerraform(ctx context.Context, diags *diag.Diagnostics, vyosData map[string]interface{}) {
	tflog.Error(ctx, "VyosToTerraform begin", map[string]interface{}{"Path": []string{"policy", "route-map", "rule", "match"}})

	// Leafs
	if value, ok := vyosData["as-path"]; ok {
		o.LeafPolicyRouteMapRuleMatchAsPath = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchAsPath = basetypes.NewStringNull()
	}
	if value, ok := vyosData["extcommunity"]; ok {
		o.LeafPolicyRouteMapRuleMatchExtcommunity = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchExtcommunity = basetypes.NewStringNull()
	}
	if value, ok := vyosData["interface"]; ok {
		o.LeafPolicyRouteMapRuleMatchInterface = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchInterface = basetypes.NewStringNull()
	}
	if value, ok := vyosData["local-preference"]; ok {
		o.LeafPolicyRouteMapRuleMatchLocalPreference = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchLocalPreference = basetypes.NewStringNull()
	}
	if value, ok := vyosData["metric"]; ok {
		o.LeafPolicyRouteMapRuleMatchMetric = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchMetric = basetypes.NewStringNull()
	}
	if value, ok := vyosData["origin"]; ok {
		o.LeafPolicyRouteMapRuleMatchOrigin = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchOrigin = basetypes.NewStringNull()
	}
	if value, ok := vyosData["peer"]; ok {
		o.LeafPolicyRouteMapRuleMatchPeer = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchPeer = basetypes.NewStringNull()
	}
	if value, ok := vyosData["rpki"]; ok {
		o.LeafPolicyRouteMapRuleMatchRpki = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchRpki = basetypes.NewStringNull()
	}
	if value, ok := vyosData["tag"]; ok {
		o.LeafPolicyRouteMapRuleMatchTag = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchTag = basetypes.NewStringNull()
	}

	// Tags

	// Nodes
	if value, ok := vyosData["community"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, PolicyRouteMapRuleMatchCommunity{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodePolicyRouteMapRuleMatchCommunity = data

	} else {
		o.NodePolicyRouteMapRuleMatchCommunity = basetypes.NewObjectNull(PolicyRouteMapRuleMatchCommunity{}.AttributeTypes())
	}
	if value, ok := vyosData["evpn"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, PolicyRouteMapRuleMatchEvpn{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodePolicyRouteMapRuleMatchEvpn = data

	} else {
		o.NodePolicyRouteMapRuleMatchEvpn = basetypes.NewObjectNull(PolicyRouteMapRuleMatchEvpn{}.AttributeTypes())
	}
	if value, ok := vyosData["ip"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, PolicyRouteMapRuleMatchIP{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodePolicyRouteMapRuleMatchIP = data

	} else {
		o.NodePolicyRouteMapRuleMatchIP = basetypes.NewObjectNull(PolicyRouteMapRuleMatchIP{}.AttributeTypes())
	}
	if value, ok := vyosData["ipv6"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, PolicyRouteMapRuleMatchIPvsix{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodePolicyRouteMapRuleMatchIPvsix = data

	} else {
		o.NodePolicyRouteMapRuleMatchIPvsix = basetypes.NewObjectNull(PolicyRouteMapRuleMatchIPvsix{}.AttributeTypes())
	}
	if value, ok := vyosData["large-community"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, PolicyRouteMapRuleMatchLargeCommunity{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodePolicyRouteMapRuleMatchLargeCommunity = data

	} else {
		o.NodePolicyRouteMapRuleMatchLargeCommunity = basetypes.NewObjectNull(PolicyRouteMapRuleMatchLargeCommunity{}.AttributeTypes())
	}

	tflog.Error(ctx, "VyosToTerraform end", map[string]interface{}{"Path": []string{"policy", "route-map", "rule", "match"}})
}

// AttributeTypes generates the attribute types for the resource at this level
func (o PolicyRouteMapRuleMatch) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		// Leafs
		"as_path":          types.StringType,
		"extcommunity":     types.StringType,
		"interface":        types.StringType,
		"local_preference": types.StringType,
		"metric":           types.StringType,
		"origin":           types.StringType,
		"peer":             types.StringType,
		"rpki":             types.StringType,
		"tag":              types.StringType,

		// Tags

		// Nodes
		"community":       types.ObjectType{AttrTypes: PolicyRouteMapRuleMatchCommunity{}.AttributeTypes()},
		"evpn":            types.ObjectType{AttrTypes: PolicyRouteMapRuleMatchEvpn{}.AttributeTypes()},
		"ip":              types.ObjectType{AttrTypes: PolicyRouteMapRuleMatchIP{}.AttributeTypes()},
		"ipv6":            types.ObjectType{AttrTypes: PolicyRouteMapRuleMatchIPvsix{}.AttributeTypes()},
		"large_community": types.ObjectType{AttrTypes: PolicyRouteMapRuleMatchLargeCommunity{}.AttributeTypes()},
	}
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o PolicyRouteMapRuleMatch) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		// LeafNodes

		"as_path": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP as-path-list to match

`,
		},

		"extcommunity": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP extended community to match

`,
		},

		"interface": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Interface to use

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Interface name  |

`,
		},

		"local_preference": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Local Preference

|  Format  |  Description  |
|----------|---------------|
|  u32:0-4294967295  |  Local Preference  |

`,
		},

		"metric": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Metric of route to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Route metric  |

`,
		},

		"origin": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP origin code to match

|  Format  |  Description  |
|----------|---------------|
|  egp  |  Exterior gateway protocol origin  |
|  igp  |  Interior gateway protocol origin  |
|  incomplete  |  Incomplete origin  |

`,
		},

		"peer": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Peer address to match

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Peer IP address  |
|  ipv6  |  Peer IPv6 address  |

`,
		},

		"rpki": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Match RPKI validation result

|  Format  |  Description  |
|----------|---------------|
|  invalid  |  Match invalid entries  |
|  notfound  |  Match notfound entries  |
|  valid  |  Match valid entries  |

`,
		},

		"tag": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Route tag to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Route tag  |

`,
		},

		// TagNodes

		// Nodes

		"community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP community-list to match

`,
		},

		"evpn": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchEvpn{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Ethernet Virtual Private Network

`,
		},

		"ip": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchIP{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IP prefix parameters to match

`,
		},

		"ipv6": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchIPvsix{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IPv6 prefix parameters to match

`,
		},

		"large_community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchLargeCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Match BGP large communities

`,
		},
	}
}
