// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// FirewallNameRule describes the resource data model.
type FirewallNameRule struct {
	// LeafNodes
	LeafFirewallNameRuleAction              types.String `tfsdk:"action"`
	LeafFirewallNameRuleDescrIPtion         types.String `tfsdk:"description"`
	LeafFirewallNameRuleDisable             types.String `tfsdk:"disable"`
	LeafFirewallNameRuleLog                 types.String `tfsdk:"log"`
	LeafFirewallNameRuleLogLevel            types.String `tfsdk:"log_level"`
	LeafFirewallNameRuleProtocol            types.String `tfsdk:"protocol"`
	LeafFirewallNameRuleDscp                types.String `tfsdk:"dscp"`
	LeafFirewallNameRuleDscpExclude         types.String `tfsdk:"dscp_exclude"`
	LeafFirewallNameRulePacketLength        types.String `tfsdk:"packet_length"`
	LeafFirewallNameRulePacketLengthExclude types.String `tfsdk:"packet_length_exclude"`
	LeafFirewallNameRulePacketType          types.String `tfsdk:"packet_type"`
	LeafFirewallNameRuleConnectionMark      types.String `tfsdk:"connection_mark"`
	LeafFirewallNameRuleJumpTarget          types.String `tfsdk:"jump_target"`
	LeafFirewallNameRuleQueue               types.String `tfsdk:"queue"`
	LeafFirewallNameRuleQueueOptions        types.String `tfsdk:"queue_options"`

	// TagNodes

	// Nodes
	NodeFirewallNameRuleDestination       types.Object `tfsdk:"destination"`
	NodeFirewallNameRuleSource            types.Object `tfsdk:"source"`
	NodeFirewallNameRuleFragment          types.Object `tfsdk:"fragment"`
	NodeFirewallNameRuleInboundInterface  types.Object `tfsdk:"inbound_interface"`
	NodeFirewallNameRuleOutboundInterface types.Object `tfsdk:"outbound_interface"`
	NodeFirewallNameRuleIPsec             types.Object `tfsdk:"ipsec"`
	NodeFirewallNameRuleLimit             types.Object `tfsdk:"limit"`
	NodeFirewallNameRuleConnectionStatus  types.Object `tfsdk:"connection_status"`
	NodeFirewallNameRuleRecent            types.Object `tfsdk:"recent"`
	NodeFirewallNameRuleState             types.Object `tfsdk:"state"`
	NodeFirewallNameRuleTCP               types.Object `tfsdk:"tcp"`
	NodeFirewallNameRuleTime              types.Object `tfsdk:"time"`
	NodeFirewallNameRuleIcmp              types.Object `tfsdk:"icmp"`
	NodeFirewallNameRuleTTL               types.Object `tfsdk:"ttl"`
}

// TerraformToVyos converts terraform data to vyos data
func (o *FirewallNameRule) TerraformToVyos(ctx context.Context, diags *diag.Diagnostics) map[string]interface{} {
	tflog.Error(ctx, "TerraformToVyos", map[string]interface{}{"Path": []string{"firewall", "name", "rule"}})

	vyosData := make(map[string]interface{})

	// Leafs
	if !(o.LeafFirewallNameRuleAction.IsNull() || o.LeafFirewallNameRuleAction.IsUnknown()) {
		vyosData["action"] = o.LeafFirewallNameRuleAction.ValueString()
	}
	if !(o.LeafFirewallNameRuleDescrIPtion.IsNull() || o.LeafFirewallNameRuleDescrIPtion.IsUnknown()) {
		vyosData["description"] = o.LeafFirewallNameRuleDescrIPtion.ValueString()
	}
	if !(o.LeafFirewallNameRuleDisable.IsNull() || o.LeafFirewallNameRuleDisable.IsUnknown()) {
		vyosData["disable"] = o.LeafFirewallNameRuleDisable.ValueString()
	}
	if !(o.LeafFirewallNameRuleLog.IsNull() || o.LeafFirewallNameRuleLog.IsUnknown()) {
		vyosData["log"] = o.LeafFirewallNameRuleLog.ValueString()
	}
	if !(o.LeafFirewallNameRuleLogLevel.IsNull() || o.LeafFirewallNameRuleLogLevel.IsUnknown()) {
		vyosData["log-level"] = o.LeafFirewallNameRuleLogLevel.ValueString()
	}
	if !(o.LeafFirewallNameRuleProtocol.IsNull() || o.LeafFirewallNameRuleProtocol.IsUnknown()) {
		vyosData["protocol"] = o.LeafFirewallNameRuleProtocol.ValueString()
	}
	if !(o.LeafFirewallNameRuleDscp.IsNull() || o.LeafFirewallNameRuleDscp.IsUnknown()) {
		vyosData["dscp"] = o.LeafFirewallNameRuleDscp.ValueString()
	}
	if !(o.LeafFirewallNameRuleDscpExclude.IsNull() || o.LeafFirewallNameRuleDscpExclude.IsUnknown()) {
		vyosData["dscp-exclude"] = o.LeafFirewallNameRuleDscpExclude.ValueString()
	}
	if !(o.LeafFirewallNameRulePacketLength.IsNull() || o.LeafFirewallNameRulePacketLength.IsUnknown()) {
		vyosData["packet-length"] = o.LeafFirewallNameRulePacketLength.ValueString()
	}
	if !(o.LeafFirewallNameRulePacketLengthExclude.IsNull() || o.LeafFirewallNameRulePacketLengthExclude.IsUnknown()) {
		vyosData["packet-length-exclude"] = o.LeafFirewallNameRulePacketLengthExclude.ValueString()
	}
	if !(o.LeafFirewallNameRulePacketType.IsNull() || o.LeafFirewallNameRulePacketType.IsUnknown()) {
		vyosData["packet-type"] = o.LeafFirewallNameRulePacketType.ValueString()
	}
	if !(o.LeafFirewallNameRuleConnectionMark.IsNull() || o.LeafFirewallNameRuleConnectionMark.IsUnknown()) {
		vyosData["connection-mark"] = o.LeafFirewallNameRuleConnectionMark.ValueString()
	}
	if !(o.LeafFirewallNameRuleJumpTarget.IsNull() || o.LeafFirewallNameRuleJumpTarget.IsUnknown()) {
		vyosData["jump-target"] = o.LeafFirewallNameRuleJumpTarget.ValueString()
	}
	if !(o.LeafFirewallNameRuleQueue.IsNull() || o.LeafFirewallNameRuleQueue.IsUnknown()) {
		vyosData["queue"] = o.LeafFirewallNameRuleQueue.ValueString()
	}
	if !(o.LeafFirewallNameRuleQueueOptions.IsNull() || o.LeafFirewallNameRuleQueueOptions.IsUnknown()) {
		vyosData["queue-options"] = o.LeafFirewallNameRuleQueueOptions.ValueString()
	}

	// Tags

	// Nodes
	if !(o.NodeFirewallNameRuleDestination.IsNull() || o.NodeFirewallNameRuleDestination.IsUnknown()) {
		var subModel FirewallNameRuleDestination
		diags.Append(o.NodeFirewallNameRuleDestination.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["destination"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleSource.IsNull() || o.NodeFirewallNameRuleSource.IsUnknown()) {
		var subModel FirewallNameRuleSource
		diags.Append(o.NodeFirewallNameRuleSource.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["source"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleFragment.IsNull() || o.NodeFirewallNameRuleFragment.IsUnknown()) {
		var subModel FirewallNameRuleFragment
		diags.Append(o.NodeFirewallNameRuleFragment.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["fragment"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleInboundInterface.IsNull() || o.NodeFirewallNameRuleInboundInterface.IsUnknown()) {
		var subModel FirewallNameRuleInboundInterface
		diags.Append(o.NodeFirewallNameRuleInboundInterface.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["inbound-interface"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleOutboundInterface.IsNull() || o.NodeFirewallNameRuleOutboundInterface.IsUnknown()) {
		var subModel FirewallNameRuleOutboundInterface
		diags.Append(o.NodeFirewallNameRuleOutboundInterface.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["outbound-interface"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleIPsec.IsNull() || o.NodeFirewallNameRuleIPsec.IsUnknown()) {
		var subModel FirewallNameRuleIPsec
		diags.Append(o.NodeFirewallNameRuleIPsec.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ipsec"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleLimit.IsNull() || o.NodeFirewallNameRuleLimit.IsUnknown()) {
		var subModel FirewallNameRuleLimit
		diags.Append(o.NodeFirewallNameRuleLimit.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["limit"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleConnectionStatus.IsNull() || o.NodeFirewallNameRuleConnectionStatus.IsUnknown()) {
		var subModel FirewallNameRuleConnectionStatus
		diags.Append(o.NodeFirewallNameRuleConnectionStatus.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["connection-status"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleRecent.IsNull() || o.NodeFirewallNameRuleRecent.IsUnknown()) {
		var subModel FirewallNameRuleRecent
		diags.Append(o.NodeFirewallNameRuleRecent.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["recent"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleState.IsNull() || o.NodeFirewallNameRuleState.IsUnknown()) {
		var subModel FirewallNameRuleState
		diags.Append(o.NodeFirewallNameRuleState.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["state"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleTCP.IsNull() || o.NodeFirewallNameRuleTCP.IsUnknown()) {
		var subModel FirewallNameRuleTCP
		diags.Append(o.NodeFirewallNameRuleTCP.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["tcp"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleTime.IsNull() || o.NodeFirewallNameRuleTime.IsUnknown()) {
		var subModel FirewallNameRuleTime
		diags.Append(o.NodeFirewallNameRuleTime.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["time"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleIcmp.IsNull() || o.NodeFirewallNameRuleIcmp.IsUnknown()) {
		var subModel FirewallNameRuleIcmp
		diags.Append(o.NodeFirewallNameRuleIcmp.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["icmp"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeFirewallNameRuleTTL.IsNull() || o.NodeFirewallNameRuleTTL.IsUnknown()) {
		var subModel FirewallNameRuleTTL
		diags.Append(o.NodeFirewallNameRuleTTL.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ttl"] = subModel.TerraformToVyos(ctx, diags)
	}

	// Return compiled data
	return vyosData
}

// VyosToTerraform converts vyos data to terraform data
func (o *FirewallNameRule) VyosToTerraform(ctx context.Context, diags *diag.Diagnostics, vyosData map[string]interface{}) {
	tflog.Error(ctx, "VyosToTerraform begin", map[string]interface{}{"Path": []string{"firewall", "name", "rule"}})

	// Leafs
	if value, ok := vyosData["action"]; ok {
		o.LeafFirewallNameRuleAction = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleAction = basetypes.NewStringNull()
	}
	if value, ok := vyosData["description"]; ok {
		o.LeafFirewallNameRuleDescrIPtion = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleDescrIPtion = basetypes.NewStringNull()
	}
	if value, ok := vyosData["disable"]; ok {
		o.LeafFirewallNameRuleDisable = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleDisable = basetypes.NewStringNull()
	}
	if value, ok := vyosData["log"]; ok {
		o.LeafFirewallNameRuleLog = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleLog = basetypes.NewStringNull()
	}
	if value, ok := vyosData["log-level"]; ok {
		o.LeafFirewallNameRuleLogLevel = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleLogLevel = basetypes.NewStringNull()
	}
	if value, ok := vyosData["protocol"]; ok {
		o.LeafFirewallNameRuleProtocol = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleProtocol = basetypes.NewStringNull()
	}
	if value, ok := vyosData["dscp"]; ok {
		o.LeafFirewallNameRuleDscp = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleDscp = basetypes.NewStringNull()
	}
	if value, ok := vyosData["dscp-exclude"]; ok {
		o.LeafFirewallNameRuleDscpExclude = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleDscpExclude = basetypes.NewStringNull()
	}
	if value, ok := vyosData["packet-length"]; ok {
		o.LeafFirewallNameRulePacketLength = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRulePacketLength = basetypes.NewStringNull()
	}
	if value, ok := vyosData["packet-length-exclude"]; ok {
		o.LeafFirewallNameRulePacketLengthExclude = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRulePacketLengthExclude = basetypes.NewStringNull()
	}
	if value, ok := vyosData["packet-type"]; ok {
		o.LeafFirewallNameRulePacketType = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRulePacketType = basetypes.NewStringNull()
	}
	if value, ok := vyosData["connection-mark"]; ok {
		o.LeafFirewallNameRuleConnectionMark = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleConnectionMark = basetypes.NewStringNull()
	}
	if value, ok := vyosData["jump-target"]; ok {
		o.LeafFirewallNameRuleJumpTarget = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleJumpTarget = basetypes.NewStringNull()
	}
	if value, ok := vyosData["queue"]; ok {
		o.LeafFirewallNameRuleQueue = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleQueue = basetypes.NewStringNull()
	}
	if value, ok := vyosData["queue-options"]; ok {
		o.LeafFirewallNameRuleQueueOptions = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafFirewallNameRuleQueueOptions = basetypes.NewStringNull()
	}

	// Tags

	// Nodes
	if value, ok := vyosData["destination"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleDestination{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleDestination = data

	} else {
		o.NodeFirewallNameRuleDestination = basetypes.NewObjectNull(FirewallNameRuleDestination{}.AttributeTypes())
	}
	if value, ok := vyosData["source"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleSource{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleSource = data

	} else {
		o.NodeFirewallNameRuleSource = basetypes.NewObjectNull(FirewallNameRuleSource{}.AttributeTypes())
	}
	if value, ok := vyosData["fragment"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleFragment{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleFragment = data

	} else {
		o.NodeFirewallNameRuleFragment = basetypes.NewObjectNull(FirewallNameRuleFragment{}.AttributeTypes())
	}
	if value, ok := vyosData["inbound-interface"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleInboundInterface{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleInboundInterface = data

	} else {
		o.NodeFirewallNameRuleInboundInterface = basetypes.NewObjectNull(FirewallNameRuleInboundInterface{}.AttributeTypes())
	}
	if value, ok := vyosData["outbound-interface"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleOutboundInterface{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleOutboundInterface = data

	} else {
		o.NodeFirewallNameRuleOutboundInterface = basetypes.NewObjectNull(FirewallNameRuleOutboundInterface{}.AttributeTypes())
	}
	if value, ok := vyosData["ipsec"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleIPsec{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleIPsec = data

	} else {
		o.NodeFirewallNameRuleIPsec = basetypes.NewObjectNull(FirewallNameRuleIPsec{}.AttributeTypes())
	}
	if value, ok := vyosData["limit"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleLimit{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleLimit = data

	} else {
		o.NodeFirewallNameRuleLimit = basetypes.NewObjectNull(FirewallNameRuleLimit{}.AttributeTypes())
	}
	if value, ok := vyosData["connection-status"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleConnectionStatus{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleConnectionStatus = data

	} else {
		o.NodeFirewallNameRuleConnectionStatus = basetypes.NewObjectNull(FirewallNameRuleConnectionStatus{}.AttributeTypes())
	}
	if value, ok := vyosData["recent"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleRecent{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleRecent = data

	} else {
		o.NodeFirewallNameRuleRecent = basetypes.NewObjectNull(FirewallNameRuleRecent{}.AttributeTypes())
	}
	if value, ok := vyosData["state"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleState{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleState = data

	} else {
		o.NodeFirewallNameRuleState = basetypes.NewObjectNull(FirewallNameRuleState{}.AttributeTypes())
	}
	if value, ok := vyosData["tcp"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleTCP{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleTCP = data

	} else {
		o.NodeFirewallNameRuleTCP = basetypes.NewObjectNull(FirewallNameRuleTCP{}.AttributeTypes())
	}
	if value, ok := vyosData["time"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleTime{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleTime = data

	} else {
		o.NodeFirewallNameRuleTime = basetypes.NewObjectNull(FirewallNameRuleTime{}.AttributeTypes())
	}
	if value, ok := vyosData["icmp"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleIcmp{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleIcmp = data

	} else {
		o.NodeFirewallNameRuleIcmp = basetypes.NewObjectNull(FirewallNameRuleIcmp{}.AttributeTypes())
	}
	if value, ok := vyosData["ttl"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, FirewallNameRuleTTL{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeFirewallNameRuleTTL = data

	} else {
		o.NodeFirewallNameRuleTTL = basetypes.NewObjectNull(FirewallNameRuleTTL{}.AttributeTypes())
	}

	tflog.Error(ctx, "VyosToTerraform end", map[string]interface{}{"Path": []string{"firewall", "name", "rule"}})
}

// AttributeTypes generates the attribute types for the resource at this level
func (o FirewallNameRule) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		// Leafs
		"action":                types.StringType,
		"description":           types.StringType,
		"disable":               types.StringType,
		"log":                   types.StringType,
		"log_level":             types.StringType,
		"protocol":              types.StringType,
		"dscp":                  types.StringType,
		"dscp_exclude":          types.StringType,
		"packet_length":         types.StringType,
		"packet_length_exclude": types.StringType,
		"packet_type":           types.StringType,
		"connection_mark":       types.StringType,
		"jump_target":           types.StringType,
		"queue":                 types.StringType,
		"queue_options":         types.StringType,

		// Tags

		// Nodes
		"destination":        types.ObjectType{AttrTypes: FirewallNameRuleDestination{}.AttributeTypes()},
		"source":             types.ObjectType{AttrTypes: FirewallNameRuleSource{}.AttributeTypes()},
		"fragment":           types.ObjectType{AttrTypes: FirewallNameRuleFragment{}.AttributeTypes()},
		"inbound_interface":  types.ObjectType{AttrTypes: FirewallNameRuleInboundInterface{}.AttributeTypes()},
		"outbound_interface": types.ObjectType{AttrTypes: FirewallNameRuleOutboundInterface{}.AttributeTypes()},
		"ipsec":              types.ObjectType{AttrTypes: FirewallNameRuleIPsec{}.AttributeTypes()},
		"limit":              types.ObjectType{AttrTypes: FirewallNameRuleLimit{}.AttributeTypes()},
		"connection_status":  types.ObjectType{AttrTypes: FirewallNameRuleConnectionStatus{}.AttributeTypes()},
		"recent":             types.ObjectType{AttrTypes: FirewallNameRuleRecent{}.AttributeTypes()},
		"state":              types.ObjectType{AttrTypes: FirewallNameRuleState{}.AttributeTypes()},
		"tcp":                types.ObjectType{AttrTypes: FirewallNameRuleTCP{}.AttributeTypes()},
		"time":               types.ObjectType{AttrTypes: FirewallNameRuleTime{}.AttributeTypes()},
		"icmp":               types.ObjectType{AttrTypes: FirewallNameRuleIcmp{}.AttributeTypes()},
		"ttl":                types.ObjectType{AttrTypes: FirewallNameRuleTTL{}.AttributeTypes()},
	}
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o FirewallNameRule) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		// LeafNodes

		"action": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Rule action

|  Format  |  Description  |
|----------|---------------|
|  accept  |  Accept matching entries  |
|  jump  |  Jump to another chain  |
|  reject  |  Reject matching entries  |
|  return  |  Return from the current chain and continue at the next rule of the                       last chain  |
|  drop  |  Drop matching entries  |
|  queue  |  Enqueue packet to userspace  |

`,
		},

		"description": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |

`,
		},

		"disable": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Option to disable firewall rule

`,
		},

		"log": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Option to log packets matching rule

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable log  |
|  disable  |  Disable log  |

`,
		},

		"log_level": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Set log-level. Log must be enable.

|  Format  |  Description  |
|----------|---------------|
|  emerg  |  Emerg log level  |
|  alert  |  Alert log level  |
|  crit  |  Critical log level  |
|  err  |  Error log level  |
|  warn  |  Warning log level  |
|  notice  |  Notice log level  |
|  info  |  Info log level  |
|  debug  |  Debug log level  |

`,
		},

		"protocol": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Protocol to match (protocol name, number, or "all")

|  Format  |  Description  |
|----------|---------------|
|  all  |  All IP protocols  |
|  tcp_udp  |  Both TCP and UDP  |
|  u32:0-255  |  IP protocol number  |
|  <protocol>  |  IP protocol name  |
|  !<protocol>  |  IP protocol name  |

`,
		},

		"dscp": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `DSCP value

|  Format  |  Description  |
|----------|---------------|
|  u32:0-63  |  DSCP value to match  |
|  <start-end>  |  DSCP range to match  |

`,
		},

		"dscp_exclude": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `DSCP value not to match

|  Format  |  Description  |
|----------|---------------|
|  u32:0-63  |  DSCP value not to match  |
|  <start-end>  |  DSCP range not to match  |

`,
		},

		"packet_length": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Payload size in bytes, including header and data to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Packet length to match  |
|  <start-end>  |  Packet length range to match  |

`,
		},

		"packet_length_exclude": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Payload size in bytes, including header and data not to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Packet length not to match  |
|  <start-end>  |  Packet length range not to match  |

`,
		},

		"packet_type": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Packet type

|  Format  |  Description  |
|----------|---------------|
|  broadcast  |  Match broadcast packet type  |
|  host  |  Match host packet type, addressed to local host  |
|  multicast  |  Match multicast packet type  |
|  other  |  Match packet addressed to another host  |

`,
		},

		"connection_mark": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Connection mark

|  Format  |  Description  |
|----------|---------------|
|  u32:0-2147483647  |  Connection-mark to match  |

`,
		},

		"jump_target": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Set jump target. Action jump must be defined to use this setting

`,
		},

		"queue": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Queue target to use. Action queue must be defined to use this setting

|  Format  |  Description  |
|----------|---------------|
|  u32:0-65535  |  Queue target  |

`,
		},

		"queue_options": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Options used for queue target. Action queue must be defined to use this
                    setting

|  Format  |  Description  |
|----------|---------------|
|  bypass  |  Let packets go through if userspace application cannot back off  |
|  fanout  |  Distribute packets between several queues  |

`,
		},

		// TagNodes

		// Nodes

		"destination": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleDestination{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Destination parameters

`,
		},

		"source": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleSource{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Source parameters

`,
		},

		"fragment": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleFragment{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IP fragment match

`,
		},

		"inbound_interface": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleInboundInterface{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Match inbound-interface

`,
		},

		"outbound_interface": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleOutboundInterface{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Match outbound-interface

`,
		},

		"ipsec": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleIPsec{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Inbound IPsec packets

`,
		},

		"limit": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleLimit{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Rate limit using a token bucket filter

`,
		},

		"connection_status": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleConnectionStatus{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Connection status

`,
		},

		"recent": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleRecent{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Parameters for matching recently seen sources

`,
		},

		"state": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleState{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Session state

`,
		},

		"tcp": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleTCP{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `TCP flags to match

`,
		},

		"time": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleTime{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Time to match rule

`,
		},

		"icmp": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleIcmp{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `ICMP type and code information

`,
		},

		"ttl": schema.SingleNestedAttribute{
			Attributes: FirewallNameRuleTTL{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Time to live limit

`,
		},
	}
}
