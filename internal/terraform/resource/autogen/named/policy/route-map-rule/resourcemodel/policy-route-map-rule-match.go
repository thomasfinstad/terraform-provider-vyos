// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"encoding/json"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// PolicyRouteMapRuleMatch describes the resource data model.
type PolicyRouteMapRuleMatch struct {
	// LeafNodes
	LeafPolicyRouteMapRuleMatchAsPath          types.String `tfsdk:"as_path" vyos:"as-path,omitempty"`
	LeafPolicyRouteMapRuleMatchExtcommunity    types.String `tfsdk:"extcommunity" vyos:"extcommunity,omitempty"`
	LeafPolicyRouteMapRuleMatchInterface       types.String `tfsdk:"interface" vyos:"interface,omitempty"`
	LeafPolicyRouteMapRuleMatchLocalPreference types.String `tfsdk:"local_preference" vyos:"local-preference,omitempty"`
	LeafPolicyRouteMapRuleMatchMetric          types.String `tfsdk:"metric" vyos:"metric,omitempty"`
	LeafPolicyRouteMapRuleMatchOrigin          types.String `tfsdk:"origin" vyos:"origin,omitempty"`
	LeafPolicyRouteMapRuleMatchPeer            types.String `tfsdk:"peer" vyos:"peer,omitempty"`
	LeafPolicyRouteMapRuleMatchRpki            types.String `tfsdk:"rpki" vyos:"rpki,omitempty"`
	LeafPolicyRouteMapRuleMatchTag             types.String `tfsdk:"tag" vyos:"tag,omitempty"`

	// TagNodes (Bools that show if child resources have been configured)

	// Nodes
	NodePolicyRouteMapRuleMatchCommunity      *PolicyRouteMapRuleMatchCommunity      `tfsdk:"community" vyos:"community,omitempty"`
	NodePolicyRouteMapRuleMatchEvpn           *PolicyRouteMapRuleMatchEvpn           `tfsdk:"evpn" vyos:"evpn,omitempty"`
	NodePolicyRouteMapRuleMatchIP             *PolicyRouteMapRuleMatchIP             `tfsdk:"ip" vyos:"ip,omitempty"`
	NodePolicyRouteMapRuleMatchIPvsix         *PolicyRouteMapRuleMatchIPvsix         `tfsdk:"ipv6" vyos:"ipv6,omitempty"`
	NodePolicyRouteMapRuleMatchLargeCommunity *PolicyRouteMapRuleMatchLargeCommunity `tfsdk:"large_community" vyos:"large-community,omitempty"`
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o PolicyRouteMapRuleMatch) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		// LeafNodes

		"as_path": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP as-path-list to match

`,
		},

		"extcommunity": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP extended community to match

`,
		},

		"interface": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Interface to use

    |  Format  |  Description  |
    |----------|---------------|
    |  txt  |  Interface name  |

`,
		},

		"local_preference": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Local Preference

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:0-4294967295  |  Local Preference  |

`,
		},

		"metric": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Metric of route to match

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:1-65535  |  Route metric  |

`,
		},

		"origin": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP origin code to match

    |  Format  |  Description  |
    |----------|---------------|
    |  egp  |  Exterior gateway protocol origin  |
    |  igp  |  Interior gateway protocol origin  |
    |  incomplete  |  Incomplete origin  |

`,
		},

		"peer": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Peer address to match

    |  Format  |  Description  |
    |----------|---------------|
    |  ipv4  |  Peer IP address  |
    |  ipv6  |  Peer IPv6 address  |

`,
		},

		"rpki": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Match RPKI validation result

    |  Format  |  Description  |
    |----------|---------------|
    |  invalid  |  Match invalid entries  |
    |  notfound  |  Match notfound entries  |
    |  valid  |  Match valid entries  |

`,
		},

		"tag": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Route tag to match

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:1-65535  |  Route tag  |

`,
		},

		// Nodes

		"community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP community-list to match

`,
		},

		"evpn": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchEvpn{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Ethernet Virtual Private Network

`,
		},

		"ip": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchIP{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IP prefix parameters to match

`,
		},

		"ipv6": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchIPvsix{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IPv6 prefix parameters to match

`,
		},

		"large_community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleMatchLargeCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Match BGP large communities

`,
		},
	}
}

// MarshalJSON returns json encoded string as bytes or error if marshalling did not go well
func (o *PolicyRouteMapRuleMatch) MarshalJSON() ([]byte, error) {
	jsonData := make(map[string]interface{})

	// Leafs

	if !o.LeafPolicyRouteMapRuleMatchAsPath.IsNull() && !o.LeafPolicyRouteMapRuleMatchAsPath.IsUnknown() {
		jsonData["as-path"] = o.LeafPolicyRouteMapRuleMatchAsPath.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchExtcommunity.IsNull() && !o.LeafPolicyRouteMapRuleMatchExtcommunity.IsUnknown() {
		jsonData["extcommunity"] = o.LeafPolicyRouteMapRuleMatchExtcommunity.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchInterface.IsNull() && !o.LeafPolicyRouteMapRuleMatchInterface.IsUnknown() {
		jsonData["interface"] = o.LeafPolicyRouteMapRuleMatchInterface.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchLocalPreference.IsNull() && !o.LeafPolicyRouteMapRuleMatchLocalPreference.IsUnknown() {
		jsonData["local-preference"] = o.LeafPolicyRouteMapRuleMatchLocalPreference.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchMetric.IsNull() && !o.LeafPolicyRouteMapRuleMatchMetric.IsUnknown() {
		jsonData["metric"] = o.LeafPolicyRouteMapRuleMatchMetric.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchOrigin.IsNull() && !o.LeafPolicyRouteMapRuleMatchOrigin.IsUnknown() {
		jsonData["origin"] = o.LeafPolicyRouteMapRuleMatchOrigin.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchPeer.IsNull() && !o.LeafPolicyRouteMapRuleMatchPeer.IsUnknown() {
		jsonData["peer"] = o.LeafPolicyRouteMapRuleMatchPeer.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchRpki.IsNull() && !o.LeafPolicyRouteMapRuleMatchRpki.IsUnknown() {
		jsonData["rpki"] = o.LeafPolicyRouteMapRuleMatchRpki.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleMatchTag.IsNull() && !o.LeafPolicyRouteMapRuleMatchTag.IsUnknown() {
		jsonData["tag"] = o.LeafPolicyRouteMapRuleMatchTag.ValueString()
	}

	// Nodes

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleMatchCommunity).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleMatchCommunity)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["community"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleMatchEvpn).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleMatchEvpn)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["evpn"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleMatchIP).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleMatchIP)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["ip"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleMatchIPvsix).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleMatchIPvsix)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["ipv6"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleMatchLargeCommunity).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleMatchLargeCommunity)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["large-community"] = subData
	}

	// Return compiled data
	ret, err := json.Marshal(jsonData)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

// UnmarshalJSON unmarshals json byte array into this object
func (o *PolicyRouteMapRuleMatch) UnmarshalJSON(jsonStr []byte) error {
	jsonData := make(map[string]interface{})
	err := json.Unmarshal(jsonStr, &jsonData)
	if err != nil {
		return err
	}

	// Leafs

	if value, ok := jsonData["as-path"]; ok {
		o.LeafPolicyRouteMapRuleMatchAsPath = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchAsPath = basetypes.NewStringNull()
	}

	if value, ok := jsonData["extcommunity"]; ok {
		o.LeafPolicyRouteMapRuleMatchExtcommunity = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchExtcommunity = basetypes.NewStringNull()
	}

	if value, ok := jsonData["interface"]; ok {
		o.LeafPolicyRouteMapRuleMatchInterface = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchInterface = basetypes.NewStringNull()
	}

	if value, ok := jsonData["local-preference"]; ok {
		o.LeafPolicyRouteMapRuleMatchLocalPreference = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchLocalPreference = basetypes.NewStringNull()
	}

	if value, ok := jsonData["metric"]; ok {
		o.LeafPolicyRouteMapRuleMatchMetric = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchMetric = basetypes.NewStringNull()
	}

	if value, ok := jsonData["origin"]; ok {
		o.LeafPolicyRouteMapRuleMatchOrigin = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchOrigin = basetypes.NewStringNull()
	}

	if value, ok := jsonData["peer"]; ok {
		o.LeafPolicyRouteMapRuleMatchPeer = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchPeer = basetypes.NewStringNull()
	}

	if value, ok := jsonData["rpki"]; ok {
		o.LeafPolicyRouteMapRuleMatchRpki = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchRpki = basetypes.NewStringNull()
	}

	if value, ok := jsonData["tag"]; ok {
		o.LeafPolicyRouteMapRuleMatchTag = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleMatchTag = basetypes.NewStringNull()
	}

	// Nodes
	if value, ok := jsonData["community"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleMatchCommunity = &PolicyRouteMapRuleMatchCommunity{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleMatchCommunity)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["evpn"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleMatchEvpn = &PolicyRouteMapRuleMatchEvpn{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleMatchEvpn)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["ip"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleMatchIP = &PolicyRouteMapRuleMatchIP{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleMatchIP)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["ipv6"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleMatchIPvsix = &PolicyRouteMapRuleMatchIPvsix{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleMatchIPvsix)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["large-community"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleMatchLargeCommunity = &PolicyRouteMapRuleMatchLargeCommunity{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleMatchLargeCommunity)
		if err != nil {
			return err
		}
	}

	return nil
}
