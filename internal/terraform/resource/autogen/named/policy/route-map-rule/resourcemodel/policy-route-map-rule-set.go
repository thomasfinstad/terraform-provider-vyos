// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"encoding/json"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// PolicyRouteMapRuleSet describes the resource data model.
type PolicyRouteMapRuleSet struct {
	// LeafNodes
	LeafPolicyRouteMapRuleSetAtomicAggregate types.String `tfsdk:"atomic_aggregate" vyos:"atomic-aggregate,omitempty"`
	LeafPolicyRouteMapRuleSetDistance        types.String `tfsdk:"distance" vyos:"distance,omitempty"`
	LeafPolicyRouteMapRuleSetIPNextHop       types.String `tfsdk:"ip_next_hop" vyos:"ip-next-hop,omitempty"`
	LeafPolicyRouteMapRuleSetLocalPreference types.String `tfsdk:"local_preference" vyos:"local-preference,omitempty"`
	LeafPolicyRouteMapRuleSetMetric          types.String `tfsdk:"metric" vyos:"metric,omitempty"`
	LeafPolicyRouteMapRuleSetMetricType      types.String `tfsdk:"metric_type" vyos:"metric-type,omitempty"`
	LeafPolicyRouteMapRuleSetOrigin          types.String `tfsdk:"origin" vyos:"origin,omitempty"`
	LeafPolicyRouteMapRuleSetOriginatorID    types.String `tfsdk:"originator_id" vyos:"originator-id,omitempty"`
	LeafPolicyRouteMapRuleSetSrc             types.String `tfsdk:"src" vyos:"src,omitempty"`
	LeafPolicyRouteMapRuleSetTable           types.String `tfsdk:"table" vyos:"table,omitempty"`
	LeafPolicyRouteMapRuleSetTag             types.String `tfsdk:"tag" vyos:"tag,omitempty"`
	LeafPolicyRouteMapRuleSetWeight          types.String `tfsdk:"weight" vyos:"weight,omitempty"`

	// TagNodes (Bools that show if child resources have been configured)

	// Nodes
	NodePolicyRouteMapRuleSetAggregator       *PolicyRouteMapRuleSetAggregator       `tfsdk:"aggregator" vyos:"aggregator,omitempty"`
	NodePolicyRouteMapRuleSetAsPath           *PolicyRouteMapRuleSetAsPath           `tfsdk:"as_path" vyos:"as-path,omitempty"`
	NodePolicyRouteMapRuleSetCommunity        *PolicyRouteMapRuleSetCommunity        `tfsdk:"community" vyos:"community,omitempty"`
	NodePolicyRouteMapRuleSetLargeCommunity   *PolicyRouteMapRuleSetLargeCommunity   `tfsdk:"large_community" vyos:"large-community,omitempty"`
	NodePolicyRouteMapRuleSetExtcommunity     *PolicyRouteMapRuleSetExtcommunity     `tfsdk:"extcommunity" vyos:"extcommunity,omitempty"`
	NodePolicyRouteMapRuleSetEvpn             *PolicyRouteMapRuleSetEvpn             `tfsdk:"evpn" vyos:"evpn,omitempty"`
	NodePolicyRouteMapRuleSetIPvsixNextHop    *PolicyRouteMapRuleSetIPvsixNextHop    `tfsdk:"ipv6_next_hop" vyos:"ipv6-next-hop,omitempty"`
	NodePolicyRouteMapRuleSetLthreevpnNexthop *PolicyRouteMapRuleSetLthreevpnNexthop `tfsdk:"l3vpn_nexthop" vyos:"l3vpn-nexthop,omitempty"`
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o PolicyRouteMapRuleSet) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		// LeafNodes

		"atomic_aggregate": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP atomic aggregate attribute

`,
		},

		"distance": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Locally significant administrative distance

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:0-255  |  Distance value  |

`,
		},

		"ip_next_hop": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Nexthop IP address

    |  Format  |  Description  |
    |----------|---------------|
    |  ipv4  |  IP address  |
    |  unchanged  |  Set the BGP nexthop address as unchanged  |
    |  peer-address  |  Set the BGP nexthop address to the address of the peer  |

`,
		},

		"local_preference": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP local preference attribute

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:0-4294967295  |  Local preference value  |

`,
		},

		"metric": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Destination routing protocol metric

    |  Format  |  Description  |
    |----------|---------------|
    |  <+/-metric>  |  Add or subtract metric  |
    |  u32:0-4294967295  |  Metric value  |

`,
		},

		"metric_type": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Open Shortest Path First (OSPF) external metric-type

    |  Format  |  Description  |
    |----------|---------------|
    |  type-1  |  OSPF external type 1 metric  |
    |  type-2  |  OSPF external type 2 metric  |

`,
		},

		"origin": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Border Gateway Protocl (BGP) origin code

    |  Format  |  Description  |
    |----------|---------------|
    |  igp  |  Interior gateway protocol origin  |
    |  egp  |  Exterior gateway protocol origin  |
    |  incomplete  |  Incomplete origin  |

`,
		},

		"originator_id": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP originator ID attribute

    |  Format  |  Description  |
    |----------|---------------|
    |  ipv4  |  Orignator IP address  |

`,
		},

		"src": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Source address for route

    |  Format  |  Description  |
    |----------|---------------|
    |  ipv4  |  IPv4 address  |
    |  ipv6  |  IPv6 address  |

`,
		},

		"table": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Set prefixes to table

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:1-200  |  Table value  |

`,
		},

		"tag": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Tag value for routing protocol

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:1-65535  |  Tag value  |

`,
		},

		"weight": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `BGP weight attribute

    |  Format  |  Description  |
    |----------|---------------|
    |  u32:0-4294967295  |  BGP weight  |

`,
		},

		// Nodes

		"aggregator": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetAggregator{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP aggregator attribute

`,
		},

		"as_path": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetAsPath{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Transform BGP AS_PATH attribute

`,
		},

		"community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP community attribute

`,
		},

		"large_community": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetLargeCommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP large community attribute

`,
		},

		"extcommunity": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetExtcommunity{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `BGP extended community attribute

`,
		},

		"evpn": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetEvpn{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Ethernet Virtual Private Network

`,
		},

		"ipv6_next_hop": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetIPvsixNextHop{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Nexthop IPv6 address

`,
		},

		"l3vpn_nexthop": schema.SingleNestedAttribute{
			Attributes: PolicyRouteMapRuleSetLthreevpnNexthop{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Next hop Information

`,
		},
	}
}

// MarshalJSON returns json encoded string as bytes or error if marshalling did not go well
func (o *PolicyRouteMapRuleSet) MarshalJSON() ([]byte, error) {
	jsonData := make(map[string]interface{})

	// Leafs

	if !o.LeafPolicyRouteMapRuleSetAtomicAggregate.IsNull() && !o.LeafPolicyRouteMapRuleSetAtomicAggregate.IsUnknown() {
		jsonData["atomic-aggregate"] = o.LeafPolicyRouteMapRuleSetAtomicAggregate.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetDistance.IsNull() && !o.LeafPolicyRouteMapRuleSetDistance.IsUnknown() {
		jsonData["distance"] = o.LeafPolicyRouteMapRuleSetDistance.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetIPNextHop.IsNull() && !o.LeafPolicyRouteMapRuleSetIPNextHop.IsUnknown() {
		jsonData["ip-next-hop"] = o.LeafPolicyRouteMapRuleSetIPNextHop.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetLocalPreference.IsNull() && !o.LeafPolicyRouteMapRuleSetLocalPreference.IsUnknown() {
		jsonData["local-preference"] = o.LeafPolicyRouteMapRuleSetLocalPreference.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetMetric.IsNull() && !o.LeafPolicyRouteMapRuleSetMetric.IsUnknown() {
		jsonData["metric"] = o.LeafPolicyRouteMapRuleSetMetric.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetMetricType.IsNull() && !o.LeafPolicyRouteMapRuleSetMetricType.IsUnknown() {
		jsonData["metric-type"] = o.LeafPolicyRouteMapRuleSetMetricType.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetOrigin.IsNull() && !o.LeafPolicyRouteMapRuleSetOrigin.IsUnknown() {
		jsonData["origin"] = o.LeafPolicyRouteMapRuleSetOrigin.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetOriginatorID.IsNull() && !o.LeafPolicyRouteMapRuleSetOriginatorID.IsUnknown() {
		jsonData["originator-id"] = o.LeafPolicyRouteMapRuleSetOriginatorID.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetSrc.IsNull() && !o.LeafPolicyRouteMapRuleSetSrc.IsUnknown() {
		jsonData["src"] = o.LeafPolicyRouteMapRuleSetSrc.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetTable.IsNull() && !o.LeafPolicyRouteMapRuleSetTable.IsUnknown() {
		jsonData["table"] = o.LeafPolicyRouteMapRuleSetTable.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetTag.IsNull() && !o.LeafPolicyRouteMapRuleSetTag.IsUnknown() {
		jsonData["tag"] = o.LeafPolicyRouteMapRuleSetTag.ValueString()
	}

	if !o.LeafPolicyRouteMapRuleSetWeight.IsNull() && !o.LeafPolicyRouteMapRuleSetWeight.IsUnknown() {
		jsonData["weight"] = o.LeafPolicyRouteMapRuleSetWeight.ValueString()
	}

	// Nodes

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetAggregator).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetAggregator)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["aggregator"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetAsPath).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetAsPath)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["as-path"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetCommunity).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetCommunity)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["community"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetLargeCommunity).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetLargeCommunity)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["large-community"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetExtcommunity).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetExtcommunity)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["extcommunity"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetEvpn).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetEvpn)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["evpn"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetIPvsixNextHop).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetIPvsixNextHop)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["ipv6-next-hop"] = subData
	}

	if !reflect.ValueOf(o.NodePolicyRouteMapRuleSetLthreevpnNexthop).IsZero() {
		subJSONStr, err := json.Marshal(o.NodePolicyRouteMapRuleSetLthreevpnNexthop)
		if err != nil {
			return nil, err
		}

		subData := make(map[string]interface{})
		err = json.Unmarshal(subJSONStr, &subData)
		if err != nil {
			return nil, err
		}
		jsonData["l3vpn-nexthop"] = subData
	}

	// Return compiled data
	ret, err := json.Marshal(jsonData)
	if err != nil {
		return nil, err
	}
	return ret, nil
}

// UnmarshalJSON unmarshals json byte array into this object
func (o *PolicyRouteMapRuleSet) UnmarshalJSON(jsonStr []byte) error {
	jsonData := make(map[string]interface{})
	err := json.Unmarshal(jsonStr, &jsonData)
	if err != nil {
		return err
	}

	// Leafs

	if value, ok := jsonData["atomic-aggregate"]; ok {
		o.LeafPolicyRouteMapRuleSetAtomicAggregate = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetAtomicAggregate = basetypes.NewStringNull()
	}

	if value, ok := jsonData["distance"]; ok {
		o.LeafPolicyRouteMapRuleSetDistance = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetDistance = basetypes.NewStringNull()
	}

	if value, ok := jsonData["ip-next-hop"]; ok {
		o.LeafPolicyRouteMapRuleSetIPNextHop = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetIPNextHop = basetypes.NewStringNull()
	}

	if value, ok := jsonData["local-preference"]; ok {
		o.LeafPolicyRouteMapRuleSetLocalPreference = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetLocalPreference = basetypes.NewStringNull()
	}

	if value, ok := jsonData["metric"]; ok {
		o.LeafPolicyRouteMapRuleSetMetric = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetMetric = basetypes.NewStringNull()
	}

	if value, ok := jsonData["metric-type"]; ok {
		o.LeafPolicyRouteMapRuleSetMetricType = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetMetricType = basetypes.NewStringNull()
	}

	if value, ok := jsonData["origin"]; ok {
		o.LeafPolicyRouteMapRuleSetOrigin = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetOrigin = basetypes.NewStringNull()
	}

	if value, ok := jsonData["originator-id"]; ok {
		o.LeafPolicyRouteMapRuleSetOriginatorID = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetOriginatorID = basetypes.NewStringNull()
	}

	if value, ok := jsonData["src"]; ok {
		o.LeafPolicyRouteMapRuleSetSrc = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetSrc = basetypes.NewStringNull()
	}

	if value, ok := jsonData["table"]; ok {
		o.LeafPolicyRouteMapRuleSetTable = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetTable = basetypes.NewStringNull()
	}

	if value, ok := jsonData["tag"]; ok {
		o.LeafPolicyRouteMapRuleSetTag = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetTag = basetypes.NewStringNull()
	}

	if value, ok := jsonData["weight"]; ok {
		o.LeafPolicyRouteMapRuleSetWeight = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafPolicyRouteMapRuleSetWeight = basetypes.NewStringNull()
	}

	// Nodes
	if value, ok := jsonData["aggregator"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetAggregator = &PolicyRouteMapRuleSetAggregator{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetAggregator)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["as-path"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetAsPath = &PolicyRouteMapRuleSetAsPath{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetAsPath)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["community"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetCommunity = &PolicyRouteMapRuleSetCommunity{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetCommunity)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["large-community"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetLargeCommunity = &PolicyRouteMapRuleSetLargeCommunity{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetLargeCommunity)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["extcommunity"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetExtcommunity = &PolicyRouteMapRuleSetExtcommunity{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetExtcommunity)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["evpn"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetEvpn = &PolicyRouteMapRuleSetEvpn{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetEvpn)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["ipv6-next-hop"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetIPvsixNextHop = &PolicyRouteMapRuleSetIPvsixNextHop{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetIPvsixNextHop)
		if err != nil {
			return err
		}
	}
	if value, ok := jsonData["l3vpn-nexthop"]; ok {
		subJSONStr, err := json.Marshal(value)
		if err != nil {
			return err
		}

		o.NodePolicyRouteMapRuleSetLthreevpnNexthop = &PolicyRouteMapRuleSetLthreevpnNexthop{}

		err = json.Unmarshal(subJSONStr, o.NodePolicyRouteMapRuleSetLthreevpnNexthop)
		if err != nil {
			return err
		}
	}

	return nil
}
