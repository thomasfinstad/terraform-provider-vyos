// Package resourcemodel code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.
package resourcemodel

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// InterfacesOpenvpn describes the resource data model.
type InterfacesOpenvpn struct {
	ID types.String `tfsdk:"identifier"`

	// LeafNodes
	LeafInterfacesOpenvpnDescrIPtion       types.String `tfsdk:"description"`
	LeafInterfacesOpenvpnDeviceType        types.String `tfsdk:"device_type"`
	LeafInterfacesOpenvpnDisable           types.String `tfsdk:"disable"`
	LeafInterfacesOpenvpnHash              types.String `tfsdk:"hash"`
	LeafInterfacesOpenvpnLocalHost         types.String `tfsdk:"local_host"`
	LeafInterfacesOpenvpnLocalPort         types.String `tfsdk:"local_port"`
	LeafInterfacesOpenvpnMode              types.String `tfsdk:"mode"`
	LeafInterfacesOpenvpnOpenvpnOption     types.String `tfsdk:"openvpn_option"`
	LeafInterfacesOpenvpnPersistentTunnel  types.String `tfsdk:"persistent_tunnel"`
	LeafInterfacesOpenvpnProtocol          types.String `tfsdk:"protocol"`
	LeafInterfacesOpenvpnRemoteAddress     types.String `tfsdk:"remote_address"`
	LeafInterfacesOpenvpnRemoteHost        types.String `tfsdk:"remote_host"`
	LeafInterfacesOpenvpnRemotePort        types.String `tfsdk:"remote_port"`
	LeafInterfacesOpenvpnSharedSecretKey   types.String `tfsdk:"shared_secret_key"`
	LeafInterfacesOpenvpnUseLzoCompression types.String `tfsdk:"use_lzo_compression"`
	LeafInterfacesOpenvpnRedirect          types.String `tfsdk:"redirect"`
	LeafInterfacesOpenvpnVrf               types.String `tfsdk:"vrf"`

	// TagNodes
	TagInterfacesOpenvpnLocalAddress types.Map `tfsdk:"local_address"`

	// Nodes
	NodeInterfacesOpenvpnAuthentication      types.Object `tfsdk:"authentication"`
	NodeInterfacesOpenvpnEncryption          types.Object `tfsdk:"encryption"`
	NodeInterfacesOpenvpnIP                  types.Object `tfsdk:"ip"`
	NodeInterfacesOpenvpnIPvsix              types.Object `tfsdk:"ipv6"`
	NodeInterfacesOpenvpnMirror              types.Object `tfsdk:"mirror"`
	NodeInterfacesOpenvpnKeepAlive           types.Object `tfsdk:"keep_alive"`
	NodeInterfacesOpenvpnReplaceDefaultRoute types.Object `tfsdk:"replace_default_route"`
	NodeInterfacesOpenvpnServer              types.Object `tfsdk:"server"`
	NodeInterfacesOpenvpnTLS                 types.Object `tfsdk:"tls"`
}

// GetVyosPath returns the list of strings to use to get to the correct vyos configuration
func (o *InterfacesOpenvpn) GetVyosPath() []string {
	return []string{
		"interfaces",
		"openvpn",
		o.ID.ValueString(),
	}
}

// TerraformToVyos converts terraform data to vyos data
func (o *InterfacesOpenvpn) TerraformToVyos(ctx context.Context, diags *diag.Diagnostics) map[string]interface{} {
	tflog.Error(ctx, "TerraformToVyos", map[string]interface{}{"Path": []string{"interfaces", "openvpn"}})

	vyosData := make(map[string]interface{})

	// Leafs
	if !(o.LeafInterfacesOpenvpnDescrIPtion.IsNull() || o.LeafInterfacesOpenvpnDescrIPtion.IsUnknown()) {
		vyosData["description"] = o.LeafInterfacesOpenvpnDescrIPtion.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnDeviceType.IsNull() || o.LeafInterfacesOpenvpnDeviceType.IsUnknown()) {
		vyosData["device-type"] = o.LeafInterfacesOpenvpnDeviceType.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnDisable.IsNull() || o.LeafInterfacesOpenvpnDisable.IsUnknown()) {
		vyosData["disable"] = o.LeafInterfacesOpenvpnDisable.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnHash.IsNull() || o.LeafInterfacesOpenvpnHash.IsUnknown()) {
		vyosData["hash"] = o.LeafInterfacesOpenvpnHash.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnLocalHost.IsNull() || o.LeafInterfacesOpenvpnLocalHost.IsUnknown()) {
		vyosData["local-host"] = o.LeafInterfacesOpenvpnLocalHost.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnLocalPort.IsNull() || o.LeafInterfacesOpenvpnLocalPort.IsUnknown()) {
		vyosData["local-port"] = o.LeafInterfacesOpenvpnLocalPort.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnMode.IsNull() || o.LeafInterfacesOpenvpnMode.IsUnknown()) {
		vyosData["mode"] = o.LeafInterfacesOpenvpnMode.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnOpenvpnOption.IsNull() || o.LeafInterfacesOpenvpnOpenvpnOption.IsUnknown()) {
		vyosData["openvpn-option"] = o.LeafInterfacesOpenvpnOpenvpnOption.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnPersistentTunnel.IsNull() || o.LeafInterfacesOpenvpnPersistentTunnel.IsUnknown()) {
		vyosData["persistent-tunnel"] = o.LeafInterfacesOpenvpnPersistentTunnel.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnProtocol.IsNull() || o.LeafInterfacesOpenvpnProtocol.IsUnknown()) {
		vyosData["protocol"] = o.LeafInterfacesOpenvpnProtocol.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnRemoteAddress.IsNull() || o.LeafInterfacesOpenvpnRemoteAddress.IsUnknown()) {
		vyosData["remote-address"] = o.LeafInterfacesOpenvpnRemoteAddress.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnRemoteHost.IsNull() || o.LeafInterfacesOpenvpnRemoteHost.IsUnknown()) {
		vyosData["remote-host"] = o.LeafInterfacesOpenvpnRemoteHost.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnRemotePort.IsNull() || o.LeafInterfacesOpenvpnRemotePort.IsUnknown()) {
		vyosData["remote-port"] = o.LeafInterfacesOpenvpnRemotePort.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnSharedSecretKey.IsNull() || o.LeafInterfacesOpenvpnSharedSecretKey.IsUnknown()) {
		vyosData["shared-secret-key"] = o.LeafInterfacesOpenvpnSharedSecretKey.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnUseLzoCompression.IsNull() || o.LeafInterfacesOpenvpnUseLzoCompression.IsUnknown()) {
		vyosData["use-lzo-compression"] = o.LeafInterfacesOpenvpnUseLzoCompression.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnRedirect.IsNull() || o.LeafInterfacesOpenvpnRedirect.IsUnknown()) {
		vyosData["redirect"] = o.LeafInterfacesOpenvpnRedirect.ValueString()
	}
	if !(o.LeafInterfacesOpenvpnVrf.IsNull() || o.LeafInterfacesOpenvpnVrf.IsUnknown()) {
		vyosData["vrf"] = o.LeafInterfacesOpenvpnVrf.ValueString()
	}

	// Tags
	if !(o.TagInterfacesOpenvpnLocalAddress.IsNull() || o.TagInterfacesOpenvpnLocalAddress.IsUnknown()) {
		subModel := make(map[string]InterfacesOpenvpnLocalAddress)
		diags.Append(o.TagInterfacesOpenvpnLocalAddress.ElementsAs(ctx, &subModel, false)...)

		subData := make(map[string]interface{})
		for k, v := range subModel {
			subData[k] = v.TerraformToVyos(ctx, diags)
		}
		vyosData["local-address"] = subData
	}

	// Nodes
	if !(o.NodeInterfacesOpenvpnAuthentication.IsNull() || o.NodeInterfacesOpenvpnAuthentication.IsUnknown()) {
		var subModel InterfacesOpenvpnAuthentication
		diags.Append(o.NodeInterfacesOpenvpnAuthentication.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["authentication"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnEncryption.IsNull() || o.NodeInterfacesOpenvpnEncryption.IsUnknown()) {
		var subModel InterfacesOpenvpnEncryption
		diags.Append(o.NodeInterfacesOpenvpnEncryption.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["encryption"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnIP.IsNull() || o.NodeInterfacesOpenvpnIP.IsUnknown()) {
		var subModel InterfacesOpenvpnIP
		diags.Append(o.NodeInterfacesOpenvpnIP.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ip"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnIPvsix.IsNull() || o.NodeInterfacesOpenvpnIPvsix.IsUnknown()) {
		var subModel InterfacesOpenvpnIPvsix
		diags.Append(o.NodeInterfacesOpenvpnIPvsix.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["ipv6"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnMirror.IsNull() || o.NodeInterfacesOpenvpnMirror.IsUnknown()) {
		var subModel InterfacesOpenvpnMirror
		diags.Append(o.NodeInterfacesOpenvpnMirror.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["mirror"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnKeepAlive.IsNull() || o.NodeInterfacesOpenvpnKeepAlive.IsUnknown()) {
		var subModel InterfacesOpenvpnKeepAlive
		diags.Append(o.NodeInterfacesOpenvpnKeepAlive.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["keep-alive"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnReplaceDefaultRoute.IsNull() || o.NodeInterfacesOpenvpnReplaceDefaultRoute.IsUnknown()) {
		var subModel InterfacesOpenvpnReplaceDefaultRoute
		diags.Append(o.NodeInterfacesOpenvpnReplaceDefaultRoute.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["replace-default-route"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnServer.IsNull() || o.NodeInterfacesOpenvpnServer.IsUnknown()) {
		var subModel InterfacesOpenvpnServer
		diags.Append(o.NodeInterfacesOpenvpnServer.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["server"] = subModel.TerraformToVyos(ctx, diags)
	}
	if !(o.NodeInterfacesOpenvpnTLS.IsNull() || o.NodeInterfacesOpenvpnTLS.IsUnknown()) {
		var subModel InterfacesOpenvpnTLS
		diags.Append(o.NodeInterfacesOpenvpnTLS.As(ctx, &subModel, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true, UnhandledUnknownAsEmpty: true})...)
		vyosData["tls"] = subModel.TerraformToVyos(ctx, diags)
	}

	// Return compiled data
	return vyosData
}

// VyosToTerraform converts vyos data to terraform data
func (o *InterfacesOpenvpn) VyosToTerraform(ctx context.Context, diags *diag.Diagnostics, vyosData map[string]interface{}) {
	tflog.Error(ctx, "VyosToTerraform begin", map[string]interface{}{"Path": []string{"interfaces", "openvpn"}})

	// Leafs
	if value, ok := vyosData["description"]; ok {
		o.LeafInterfacesOpenvpnDescrIPtion = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnDescrIPtion = basetypes.NewStringNull()
	}
	if value, ok := vyosData["device-type"]; ok {
		o.LeafInterfacesOpenvpnDeviceType = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnDeviceType = basetypes.NewStringNull()
	}
	if value, ok := vyosData["disable"]; ok {
		o.LeafInterfacesOpenvpnDisable = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnDisable = basetypes.NewStringNull()
	}
	if value, ok := vyosData["hash"]; ok {
		o.LeafInterfacesOpenvpnHash = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnHash = basetypes.NewStringNull()
	}
	if value, ok := vyosData["local-host"]; ok {
		o.LeafInterfacesOpenvpnLocalHost = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnLocalHost = basetypes.NewStringNull()
	}
	if value, ok := vyosData["local-port"]; ok {
		o.LeafInterfacesOpenvpnLocalPort = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnLocalPort = basetypes.NewStringNull()
	}
	if value, ok := vyosData["mode"]; ok {
		o.LeafInterfacesOpenvpnMode = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnMode = basetypes.NewStringNull()
	}
	if value, ok := vyosData["openvpn-option"]; ok {
		o.LeafInterfacesOpenvpnOpenvpnOption = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnOpenvpnOption = basetypes.NewStringNull()
	}
	if value, ok := vyosData["persistent-tunnel"]; ok {
		o.LeafInterfacesOpenvpnPersistentTunnel = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnPersistentTunnel = basetypes.NewStringNull()
	}
	if value, ok := vyosData["protocol"]; ok {
		o.LeafInterfacesOpenvpnProtocol = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnProtocol = basetypes.NewStringNull()
	}
	if value, ok := vyosData["remote-address"]; ok {
		o.LeafInterfacesOpenvpnRemoteAddress = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnRemoteAddress = basetypes.NewStringNull()
	}
	if value, ok := vyosData["remote-host"]; ok {
		o.LeafInterfacesOpenvpnRemoteHost = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnRemoteHost = basetypes.NewStringNull()
	}
	if value, ok := vyosData["remote-port"]; ok {
		o.LeafInterfacesOpenvpnRemotePort = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnRemotePort = basetypes.NewStringNull()
	}
	if value, ok := vyosData["shared-secret-key"]; ok {
		o.LeafInterfacesOpenvpnSharedSecretKey = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnSharedSecretKey = basetypes.NewStringNull()
	}
	if value, ok := vyosData["use-lzo-compression"]; ok {
		o.LeafInterfacesOpenvpnUseLzoCompression = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnUseLzoCompression = basetypes.NewStringNull()
	}
	if value, ok := vyosData["redirect"]; ok {
		o.LeafInterfacesOpenvpnRedirect = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnRedirect = basetypes.NewStringNull()
	}
	if value, ok := vyosData["vrf"]; ok {
		o.LeafInterfacesOpenvpnVrf = basetypes.NewStringValue(value.(string))
	} else {
		o.LeafInterfacesOpenvpnVrf = basetypes.NewStringNull()
	}

	// Tags
	if value, ok := vyosData["local-address"]; ok {
		data, d := types.MapValueFrom(ctx, types.ObjectType{AttrTypes: InterfacesOpenvpnLocalAddress{}.AttributeTypes()}, value.(map[string]interface{}))
		diags.Append(d...)
		o.TagInterfacesOpenvpnLocalAddress = data
	} else {
		o.TagInterfacesOpenvpnLocalAddress = basetypes.NewMapNull(types.ObjectType{})
	}

	// Nodes
	if value, ok := vyosData["authentication"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnAuthentication{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnAuthentication = data

	} else {
		o.NodeInterfacesOpenvpnAuthentication = basetypes.NewObjectNull(InterfacesOpenvpnAuthentication{}.AttributeTypes())
	}
	if value, ok := vyosData["encryption"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnEncryption{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnEncryption = data

	} else {
		o.NodeInterfacesOpenvpnEncryption = basetypes.NewObjectNull(InterfacesOpenvpnEncryption{}.AttributeTypes())
	}
	if value, ok := vyosData["ip"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnIP{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnIP = data

	} else {
		o.NodeInterfacesOpenvpnIP = basetypes.NewObjectNull(InterfacesOpenvpnIP{}.AttributeTypes())
	}
	if value, ok := vyosData["ipv6"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnIPvsix{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnIPvsix = data

	} else {
		o.NodeInterfacesOpenvpnIPvsix = basetypes.NewObjectNull(InterfacesOpenvpnIPvsix{}.AttributeTypes())
	}
	if value, ok := vyosData["mirror"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnMirror{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnMirror = data

	} else {
		o.NodeInterfacesOpenvpnMirror = basetypes.NewObjectNull(InterfacesOpenvpnMirror{}.AttributeTypes())
	}
	if value, ok := vyosData["keep-alive"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnKeepAlive{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnKeepAlive = data

	} else {
		o.NodeInterfacesOpenvpnKeepAlive = basetypes.NewObjectNull(InterfacesOpenvpnKeepAlive{}.AttributeTypes())
	}
	if value, ok := vyosData["replace-default-route"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnReplaceDefaultRoute{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnReplaceDefaultRoute = data

	} else {
		o.NodeInterfacesOpenvpnReplaceDefaultRoute = basetypes.NewObjectNull(InterfacesOpenvpnReplaceDefaultRoute{}.AttributeTypes())
	}
	if value, ok := vyosData["server"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnServer{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnServer = data

	} else {
		o.NodeInterfacesOpenvpnServer = basetypes.NewObjectNull(InterfacesOpenvpnServer{}.AttributeTypes())
	}
	if value, ok := vyosData["tls"]; ok {
		data, d := basetypes.NewObjectValueFrom(ctx, InterfacesOpenvpnTLS{}.AttributeTypes(), value.(map[string]interface{}))
		diags.Append(d...)
		o.NodeInterfacesOpenvpnTLS = data

	} else {
		o.NodeInterfacesOpenvpnTLS = basetypes.NewObjectNull(InterfacesOpenvpnTLS{}.AttributeTypes())
	}

	tflog.Error(ctx, "VyosToTerraform end", map[string]interface{}{"Path": []string{"interfaces", "openvpn"}})
}

// AttributeTypes generates the attribute types for the resource at this level
func (o InterfacesOpenvpn) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		// Leafs
		"description":         types.StringType,
		"device_type":         types.StringType,
		"disable":             types.StringType,
		"hash":                types.StringType,
		"local_host":          types.StringType,
		"local_port":          types.StringType,
		"mode":                types.StringType,
		"openvpn_option":      types.StringType,
		"persistent_tunnel":   types.StringType,
		"protocol":            types.StringType,
		"remote_address":      types.StringType,
		"remote_host":         types.StringType,
		"remote_port":         types.StringType,
		"shared_secret_key":   types.StringType,
		"use_lzo_compression": types.StringType,
		"redirect":            types.StringType,
		"vrf":                 types.StringType,

		// Tags
		"local_address": types.MapType{ElemType: types.ObjectType{AttrTypes: InterfacesOpenvpnLocalAddress{}.AttributeTypes()}},

		// Nodes
		"authentication":        types.ObjectType{AttrTypes: InterfacesOpenvpnAuthentication{}.AttributeTypes()},
		"encryption":            types.ObjectType{AttrTypes: InterfacesOpenvpnEncryption{}.AttributeTypes()},
		"ip":                    types.ObjectType{AttrTypes: InterfacesOpenvpnIP{}.AttributeTypes()},
		"ipv6":                  types.ObjectType{AttrTypes: InterfacesOpenvpnIPvsix{}.AttributeTypes()},
		"mirror":                types.ObjectType{AttrTypes: InterfacesOpenvpnMirror{}.AttributeTypes()},
		"keep_alive":            types.ObjectType{AttrTypes: InterfacesOpenvpnKeepAlive{}.AttributeTypes()},
		"replace_default_route": types.ObjectType{AttrTypes: InterfacesOpenvpnReplaceDefaultRoute{}.AttributeTypes()},
		"server":                types.ObjectType{AttrTypes: InterfacesOpenvpnServer{}.AttributeTypes()},
		"tls":                   types.ObjectType{AttrTypes: InterfacesOpenvpnTLS{}.AttributeTypes()},
	}
}

// ResourceSchemaAttributes generates the schema attributes for the resource at this level
func (o InterfacesOpenvpn) ResourceSchemaAttributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"identifier": schema.StringAttribute{
			Required: true,
			MarkdownDescription: `OpenVPN Tunnel Interface

|  Format  |  Description  |
|----------|---------------|
|  vtunN  |  OpenVPN interface name  |

`,
		},

		// LeafNodes

		"description": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |

`,
		},

		"device_type": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `OpenVPN interface device-type

|  Format  |  Description  |
|----------|---------------|
|  tun  |  TUN device, required for OSI layer 3  |
|  tap  |  TAP device, required for OSI layer 2  |

`,

			// Default:          stringdefault.StaticString(`tun`),
			Computed: true,
		},

		"disable": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Administratively disable interface

`,
		},

		"hash": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Hashing Algorithm

|  Format  |  Description  |
|----------|---------------|
|  md5  |  MD5 algorithm  |
|  sha1  |  SHA-1 algorithm  |
|  sha256  |  SHA-256 algorithm  |
|  sha384  |  SHA-384 algorithm  |
|  sha512  |  SHA-512 algorithm  |

`,
		},

		"local_host": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Local IP address to accept connections (all if not set)

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Local IPv4 address  |
|  ipv6  |  Local IPv6 address  |

`,
		},

		"local_port": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Local port number to accept connections

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Numeric IP port  |

`,
		},

		"mode": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `OpenVPN mode of operation

|  Format  |  Description  |
|----------|---------------|
|  site-to-site  |  Site-to-site mode  |
|  client  |  Client in client-server mode  |
|  server  |  Server in client-server mode  |

`,
		},

		"openvpn_option": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Additional OpenVPN options. You must use the syntax of openvpn.conf in this text-field. Using this without proper knowledge may result in a crashed OpenVPN server. Check system log to look for errors.

`,
		},

		"persistent_tunnel": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Do not close and reopen interface (TUN/TAP device) on client restarts

`,
		},

		"protocol": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `OpenVPN communication protocol

|  Format  |  Description  |
|----------|---------------|
|  udp  |  UDP  |
|  tcp-passive  |  TCP and accepts connections passively  |
|  tcp-active  |  TCP and initiates connections actively  |

`,

			// Default:          stringdefault.StaticString(`udp`),
			Computed: true,
		},

		"remote_address": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `IP address of remote end of tunnel

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Remote end IPv4 address  |
|  ipv6  |  Remote end IPv6 address  |

`,
		},

		"remote_host": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Remote host to connect to (dynamic if not set)

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address of remote host  |
|  ipv6  |  IPv6 address of remote host  |
|  txt  |  Hostname of remote host  |

`,
		},

		"remote_port": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Remote port number to connect to

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Numeric IP port  |

`,
		},

		"shared_secret_key": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Secret key shared with remote end of tunnel

`,
		},

		"use_lzo_compression": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Use fast LZO compression on this TUN/TAP interface

`,
		},

		"redirect": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `Redirect incoming packet to destination

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Destination interface name  |

`,
		},

		"vrf": schema.StringAttribute{
			Optional: true,
			MarkdownDescription: `VRF instance name

|  Format  |  Description  |
|----------|---------------|
|  txt  |  VRF instance name  |

`,
		},

		// TagNodes

		"local_address": schema.MapNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: InterfacesOpenvpnLocalAddress{}.ResourceSchemaAttributes(),
			},
			Optional: true,
			MarkdownDescription: `Local IP address of tunnel (IPv4 or IPv6)

`,
		},

		// Nodes

		"authentication": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnAuthentication{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Authentication settings

`,
		},

		"encryption": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnEncryption{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Data Encryption settings

`,
		},

		"ip": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnIP{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IPv4 routing parameters

`,
		},

		"ipv6": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnIPvsix{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `IPv6 routing parameters

`,
		},

		"mirror": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnMirror{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Mirror ingress/egress packets

`,
		},

		"keep_alive": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnKeepAlive{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Keepalive helper options

`,
		},

		"replace_default_route": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnReplaceDefaultRoute{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `OpenVPN tunnel to be used as the default route

`,
		},

		"server": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnServer{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Server-mode options

`,
		},

		"tls": schema.SingleNestedAttribute{
			Attributes: InterfacesOpenvpnTLS{}.ResourceSchemaAttributes(),
			Optional:   true,
			MarkdownDescription: `Transport Layer Security (TLS) options

`,
		},
	}
}
