// Code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.

package resourcefull

import (
	"context"
	"net/http"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &high_availability_vrrp_group{}

// var _ resource.ResourceWithImportState = &high_availability_vrrp_group{}

// high_availability_vrrp_group defines the resource implementation.
type high_availability_vrrp_group struct {
	client   *http.Client
	vyosPath []string
}

// high_availability_vrrp_groupModel describes the resource data model.
type high_availability_vrrp_groupModel struct {
	ID types.String `tfsdk:"identifier"`

	// LeafNodes
	Iface                               types.String `tfsdk:"interface"`
	Advertise_interval                  types.String `tfsdk:"advertise_interval"`
	Description                         types.String `tfsdk:"description"`
	Disable                             types.String `tfsdk:"disable"`
	Hello_source_address                types.String `tfsdk:"hello_source_address"`
	Peer_address                        types.String `tfsdk:"peer_address"`
	No_preempt                          types.String `tfsdk:"no_preempt"`
	Preempt_delay                       types.String `tfsdk:"preempt_delay"`
	Priority                            types.String `tfsdk:"priority"`
	Rfcthreesevensixeight_compatibility types.String `tfsdk:"rfc3768_compatibility"`
	Excluded_address                    types.String `tfsdk:"excluded_address"`
	Vrid                                types.String `tfsdk:"vrid"`

	// TagNodes
	Address types.Map `tfsdk:"address"`

	// Nodes
	Garp              types.List `tfsdk:"garp"`
	Authentication    types.List `tfsdk:"authentication"`
	Health_check      types.List `tfsdk:"health_check"`
	Track             types.List `tfsdk:"track"`
	Transition_script types.List `tfsdk:"transition_script"`
}

// Metadata method to define the resource type name.
func (r *high_availability_vrrp_group) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_high_availability_vrrp_group"
}

// high_availability_vrrp_groupResource method to return the example resource reference
func high_availability_vrrp_groupResource() resource.Resource {
	return &high_availability_vrrp_group{
		vyosPath: []string{
			"high-availability",
			"vrrp",
			"group",
		},
	}
}

// Schema method to define the schema for any resource configuration, plan, and state data.
func (r *high_availability_vrrp_group) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `High availability settings

Virtual Router Redundancy Protocol settings

`,

		Attributes: map[string]schema.Attribute{
			"identifier": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `VRRP group

`,
			},

			"address": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{

						"interface": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Interface Name to use

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Interface name  |
`,
						},
					},
				},
				Optional: true,
				MarkdownDescription: `Virtual IP address

|  Format  |  Description  |
|----------|---------------|
|  ipv4net  |  IPv4 address and prefix length  |
|  ipv6net  |  IPv6 address and prefix length  |
`,
			},

			"interface": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Interface Name to use

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Interface name  |
`,
			},

			"advertise_interval": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Advertise interval

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Advertise interval in seconds  |
`,

				Default:  stringdefault.StaticString(`1`),
				Computed: true,
			},

			"description": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |
`,
			},

			"disable": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Disable instance

`,
			},

			"hello_source_address": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `VRRP hello source address

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 hello source address  |
|  ipv6  |  IPv6 hello source address  |
`,
			},

			"peer_address": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Unicast VRRP peer address

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 unicast peer address  |
|  ipv6  |  IPv6 unicast peer address  |
`,
			},

			"no_preempt": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Disable master preemption

`,
			},

			"preempt_delay": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Preempt delay (in seconds)

|  Format  |  Description  |
|----------|---------------|
|  u32:0-1000  |  preempt delay  |
`,

				Default:  stringdefault.StaticString(`0`),
				Computed: true,
			},

			"priority": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Router priority

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Router priority  |
`,

				Default:  stringdefault.StaticString(`100`),
				Computed: true,
			},

			"rfc3768_compatibility": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Use VRRP virtual MAC address as per RFC3768

`,
			},

			"excluded_address": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Virtual address (If you need additional IPv4 and IPv6 in same group)

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IP address  |
|  ipv6  |  IPv6 address  |
`,
			},

			"vrid": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Virtual router identifier

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Virtual router identifier  |
`,
			},

			"garp": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"interval": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Interval between Gratuitous ARP

|  Format  |  Description  |
|----------|---------------|
|  <0.000-1000>  |  Interval in seconds, resolution microseconds  |
`,

						Default:  stringdefault.StaticString(`0`),
						Computed: true,
					},

					"master_delay": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Delay for second set of gratuitous ARPs after transition to master

|  Format  |  Description  |
|----------|---------------|
|  u32:1-1000  |  Delay in seconds  |
`,

						Default:  stringdefault.StaticString(`5`),
						Computed: true,
					},

					"master_refresh": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Minimum time interval for refreshing gratuitous ARPs while beeing master

|  Format  |  Description  |
|----------|---------------|
|  u32:0  |  No refresh  |
|  u32:1-255  |  Interval in seconds  |
`,

						Default:  stringdefault.StaticString(`5`),
						Computed: true,
					},

					"master_refresh_repeat": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Number of gratuitous ARP messages to send at a time while beeing master

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Number of gratuitous ARP messages  |
`,

						Default:  stringdefault.StaticString(`1`),
						Computed: true,
					},

					"master_repeat": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Number of gratuitous ARP messages to send at a time after transition to master

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Number of gratuitous ARP messages  |
`,

						Default:  stringdefault.StaticString(`5`),
						Computed: true,
					},
				},
				Optional: true,
				MarkdownDescription: `Gratuitous ARP parameters

`,
			},

			"authentication": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"password": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `VRRP password

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Password string (up to 8 characters)  |
`,
					},

					"type": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Authentication type

|  Format  |  Description  |
|----------|---------------|
|  plaintext-password  |  Simple password string  |
|  ah  |  AH - IPSEC (not recommended)  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `VRRP authentication

`,
			},

			"health_check": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"failure_count": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Health check failure count required for transition to fault

`,

						Default:  stringdefault.StaticString(`3`),
						Computed: true,
					},

					"interval": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Health check execution interval in seconds

`,

						Default:  stringdefault.StaticString(`60`),
						Computed: true,
					},

					"script": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Health check script file

`,
					},
				},
				Optional: true,
				MarkdownDescription: `Health check script

`,
			},

			"track": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"exclude_vrrp_interface": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Disable track state of main interface

`,
					},

					"interface": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Interface name state check

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Interface name  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Track settings

`,
			},

			"transition_script": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"master": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Script to run on VRRP state transition to master

`,
					},

					"backup": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Script to run on VRRP state transition to backup

`,
					},

					"fault": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Script to run on VRRP state transition to fault

`,
					},

					"stop": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Script to run on VRRP state transition to stop

`,
					},
				},
				Optional: true,
				MarkdownDescription: `VRRP transition scripts

`,
			},
		},
	}
}

// Create method to define the logic which creates the resource and sets its initial Terraform state.
func (r *high_availability_vrrp_group) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *high_availability_vrrp_groupModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create example, got error: %s", err))
	//     return
	// }

	// For the purposes of this example code, hardcoding a response value to
	// save into the Terraform state.
	data.ID = types.StringValue("example-id")

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read method to define the logic which refreshes the Terraform state for the resource.
func (r *high_availability_vrrp_group) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *high_availability_vrrp_groupModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
func (r *high_availability_vrrp_group) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *high_availability_vrrp_groupModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
func (r *high_availability_vrrp_group) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *high_availability_vrrp_groupModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }
}
