// Code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.

package resourcefull

import (
	"context"
	"net/http"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &protocols_bgp_peer_group{}

// var _ resource.ResourceWithImportState = &protocols_bgp_peer_group{}

// protocols_bgp_peer_group defines the resource implementation.
type protocols_bgp_peer_group struct {
	client   *http.Client
	vyosPath []string
}

// protocols_bgp_peer_groupModel describes the resource data model.
type protocols_bgp_peer_groupModel struct {
	ID types.String `tfsdk:"identifier"`

	// LeafNodes
	Description                    types.String `tfsdk:"description"`
	Disable_capability_negotiation types.String `tfsdk:"disable_capability_negotiation"`
	Disable_connected_check        types.String `tfsdk:"disable_connected_check"`
	Ebgp_multihop                  types.String `tfsdk:"ebgp_multihop"`
	Graceful_restart               types.String `tfsdk:"graceful_restart"`
	Override_capability            types.String `tfsdk:"override_capability"`
	Passive                        types.String `tfsdk:"passive"`
	Password                       types.String `tfsdk:"password"`
	Remote_as                      types.String `tfsdk:"remote_as"`
	Shutdown                       types.String `tfsdk:"shutdown"`
	Update_source                  types.String `tfsdk:"update_source"`

	// TagNodes
	Local_as   types.Map `tfsdk:"local_as"`
	Local_role types.Map `tfsdk:"local_role"`

	// Nodes
	Address_family types.List `tfsdk:"address_family"`
	Bfd            types.List `tfsdk:"bfd"`
	Capability     types.List `tfsdk:"capability"`
	Ttl_security   types.List `tfsdk:"ttl_security"`
}

// Metadata method to define the resource type name.
func (r *protocols_bgp_peer_group) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_protocols_bgp_peer_group"
}

// protocols_bgp_peer_groupResource method to return the example resource reference
func protocols_bgp_peer_groupResource() resource.Resource {
	return &protocols_bgp_peer_group{
		vyosPath: []string{
			"protocols",
			"bgp",
			"peer-group",
		},
	}
}

// Schema method to define the schema for any resource configuration, plan, and state data.
func (r *protocols_bgp_peer_group) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `Border Gateway Protocol (BGP)

`,

		Attributes: map[string]schema.Attribute{
			"identifier": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `Name of peer-group

`,
			},

			"local_as": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{

						"no_prepend": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"replace_as": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Prepend only local-as from/to updates for eBGP peers

`,
								},
							},
							Optional: true,
							MarkdownDescription: `Disable prepending local-as from/to updates for eBGP peers

`,
						},
					},
				},
				Optional: true,
				MarkdownDescription: `Specify alternate ASN for this BGP process

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967294  |  Autonomous System Number (ASN)  |
`,
			},

			"local_role": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{

						"strict": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Neighbor must send this exact capability, otherwise a role missmatch notification will be sent

`,
						},
					},
				},
				Optional: true,
				MarkdownDescription: `Local role for BGP neighbor (RFC9234)

|  Format  |  Description  |
|----------|---------------|
|  customer  |  Using Transit  |
|  peer  |  Public/Private Peering  |
|  provider  |  Providing Transit  |
|  rs-client  |  RS Client  |
|  rs-server  |  Route Server  |
`,
			},

			"description": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |
`,
			},

			"disable_capability_negotiation": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Disable capability negotiation with this neighbor

`,
			},

			"disable_connected_check": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Disable check to see if eBGP peer address is a connected route

`,
			},

			"ebgp_multihop": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Allow this EBGP neighbor to not be on a directly connected network

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Number of hops  |
`,
			},

			"graceful_restart": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `BGP graceful restart functionality

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable BGP graceful restart at peer level  |
|  disable  |  Disable BGP graceful restart at peer level  |
|  restart-helper  |  Enable BGP graceful restart helper only functionality  |
`,
			},

			"override_capability": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Ignore capability negotiation with specified neighbor

`,
			},

			"passive": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Do not initiate a session with this neighbor

`,
			},

			"password": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `BGP MD5 password

`,
			},

			"remote_as": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Neighbor BGP AS number

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967294  |  Neighbor AS number  |
|  external  |  Any AS different from the local AS  |
|  internal  |  Neighbor AS number  |
`,
			},

			"shutdown": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Administratively shutdown this neighbor

`,
			},

			"update_source": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Source IP of routing updates

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address of route source  |
|  ipv6  |  IPv6 address of route source  |
|  txt  |  Interface as route source  |
`,
			},

			"address_family": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"ipv4_unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"addpath_tx_all": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Use addpath to advertise all paths to a neighbor

`,
							},

							"addpath_tx_per_as": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Use addpath to advertise the bestpath per each neighboring AS

`,
							},

							"as_override": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Override ASN in outbound updates to configured neighbor local-as

`,
							},

							"maximum_prefix": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Maximum number of prefixes to accept from this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967295  |  Prefix limit  |
`,
							},

							"maximum_prefix_out": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Maximum number of prefixes to be sent to this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967295  |  Prefix limit  |
`,
							},

							"remove_private_as": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Remove private AS numbers from AS path in outbound route updates

`,
							},

							"route_reflector_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route reflector client

`,
							},

							"route_server_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route server client

`,
							},

							"unsuppress_map": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Route-map to selectively unsuppress suppressed routes

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
							},

							"weight": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Default weight for routes from this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Default weight  |
`,
							},

							"capability": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"orf": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{

											"prefix_list": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{

													"receive": schema.StringAttribute{

														Optional: true,
														MarkdownDescription: `Capability to receive the ORF

`,
													},

													"send": schema.StringAttribute{

														Optional: true,
														MarkdownDescription: `Capability to send the ORF

`,
													},
												},
												Optional: true,
												MarkdownDescription: `Advertise prefix-list ORF capability to this peer

`,
											},
										},
										Optional: true,
										MarkdownDescription: `Advertise ORF capability to this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Advertise capabilities to this neighbor (IPv4)

`,
							},

							"prefix_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `IPv4-Prefix-list to filter outgoing route updates to this peer

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of IPv4 prefix-list  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `IPv4-Prefix-list to filter incoming route updates from this peer

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of IPv4 prefix-list  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `IPv4-Prefix-list to filter route updates to/from this peer

`,
							},

							"conditionally_advertise": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"advertise_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to conditionally advertise routes

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"exist_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Advertise routes only if prefixes in exist-map are installed in BGP table

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"non_exist_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Advertise routes only if prefixes in non-exist-map are not installed in BGP table

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Use route-map to conditionally advertise routes

`,
							},

							"allowas_in": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"number": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Number of occurrences of AS number

|  Format  |  Description  |
|----------|---------------|
|  u32:1-10  |  Number of times AS is allowed in path  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Accept route that contains the local-as in the as-path

`,
							},

							"attribute_unchanged": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"as_path": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send AS path unchanged

`,
									},

									"med": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send multi-exit discriminator unchanged

`,
									},

									"next_hop": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send nexthop unchanged

`,
									},
								},
								Optional: true,
								MarkdownDescription: `BGP attributes are sent unchanged

`,
							},

							"disable_send_community": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"extended": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Disable sending extended community attributes to this peer

`,
									},

									"standard": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Disable sending standard community attributes to this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Disable sending community attributes to this peer

`,
							},

							"distribute_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Access-list to filter outgoing route updates to this peer-group

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Access-list to filter outgoing route updates to this peer-group  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Access-list to filter incoming route updates from this peer-group

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Access-list to filter incoming route updates from this peer-group  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Access-list to filter route updates to/from this peer-group

`,
							},

							"filter_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `As-path-list to filter outgoing route updates to this peer

`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `As-path-list to filter incoming route updates from this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `as-path-list to filter route updates to/from this peer

`,
							},

							"nexthop_self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"force": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Set the next hop to self for reflected routes

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Disable the next hop calculation for this peer

`,
							},

							"route_map": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter outgoing route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter incoming route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Route-map to filter route updates to/from this peer

`,
							},

							"soft_reconfiguration": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"inbound": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Enable inbound soft reconfiguration

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Soft reconfiguration for peer

`,
							},

							"default_originate": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"route_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Specify route-map name to use

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Originate default route to this peer

`,
							},
						},
						Optional: true,
						MarkdownDescription: `IPv4 BGP neighbor parameters

`,
					},

					"ipv6_unicast": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"addpath_tx_all": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Use addpath to advertise all paths to a neighbor

`,
							},

							"addpath_tx_per_as": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Use addpath to advertise the bestpath per each neighboring AS

`,
							},

							"as_override": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Override ASN in outbound updates to configured neighbor local-as

`,
							},

							"maximum_prefix": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Maximum number of prefixes to accept from this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967295  |  Prefix limit  |
`,
							},

							"maximum_prefix_out": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Maximum number of prefixes to be sent to this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4294967295  |  Prefix limit  |
`,
							},

							"remove_private_as": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Remove private AS numbers from AS path in outbound route updates

`,
							},

							"route_reflector_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route reflector client

`,
							},

							"route_server_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route server client

`,
							},

							"unsuppress_map": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Route-map to selectively unsuppress suppressed routes

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
							},

							"weight": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Default weight for routes from this peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Default weight  |
`,
							},

							"capability": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"orf": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{

											"prefix_list": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{

													"receive": schema.StringAttribute{

														Optional: true,
														MarkdownDescription: `Capability to receive the ORF

`,
													},

													"send": schema.StringAttribute{

														Optional: true,
														MarkdownDescription: `Capability to send the ORF

`,
													},
												},
												Optional: true,
												MarkdownDescription: `Advertise prefix-list ORF capability to this peer

`,
											},
										},
										Optional: true,
										MarkdownDescription: `Advertise ORF capability to this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Advertise capabilities to this neighbor (IPv6)

`,
							},

							"nexthop_local": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"unchanged": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Leave link-local nexthop unchanged for this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Nexthop attributes

`,
							},

							"prefix_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Prefix-list to filter outgoing route updates to this peer

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of IPv6 prefix-list  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Prefix-list to filter incoming route updates from this peer

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of IPv6 prefix-list  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Prefix-list to filter route updates to/from this peer

`,
							},

							"conditionally_advertise": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"advertise_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to conditionally advertise routes

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"exist_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Advertise routes only if prefixes in exist-map are installed in BGP table

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"non_exist_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Advertise routes only if prefixes in non-exist-map are not installed in BGP table

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Use route-map to conditionally advertise routes

`,
							},

							"allowas_in": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"number": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Number of occurrences of AS number

|  Format  |  Description  |
|----------|---------------|
|  u32:1-10  |  Number of times AS is allowed in path  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Accept route that contains the local-as in the as-path

`,
							},

							"attribute_unchanged": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"as_path": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send AS path unchanged

`,
									},

									"med": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send multi-exit discriminator unchanged

`,
									},

									"next_hop": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send nexthop unchanged

`,
									},
								},
								Optional: true,
								MarkdownDescription: `BGP attributes are sent unchanged

`,
							},

							"disable_send_community": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"extended": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Disable sending extended community attributes to this peer

`,
									},

									"standard": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Disable sending standard community attributes to this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Disable sending community attributes to this peer

`,
							},

							"distribute_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Access-list to filter outgoing route updates to this peer-group

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Access-list to filter outgoing route updates to this peer-group  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Access-list to filter incoming route updates from this peer-group

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Access-list to filter incoming route updates from this peer-group  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Access-list to filter route updates to/from this peer-group

`,
							},

							"filter_list": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `As-path-list to filter outgoing route updates to this peer

`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `As-path-list to filter incoming route updates from this peer

`,
									},
								},
								Optional: true,
								MarkdownDescription: `as-path-list to filter route updates to/from this peer

`,
							},

							"nexthop_self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"force": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Set the next hop to self for reflected routes

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Disable the next hop calculation for this peer

`,
							},

							"route_map": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter outgoing route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter incoming route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Route-map to filter route updates to/from this peer

`,
							},

							"soft_reconfiguration": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"inbound": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Enable inbound soft reconfiguration

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Soft reconfiguration for peer

`,
							},

							"default_originate": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"route_map": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Specify route-map name to use

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Originate default route to this peer

`,
							},
						},
						Optional: true,
						MarkdownDescription: `IPv6 BGP neighbor parameters

`,
					},

					"l2vpn_evpn": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"route_reflector_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route reflector client

`,
							},

							"route_server_client": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Peer is a route server client

`,
							},

							"allowas_in": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"number": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Number of occurrences of AS number

|  Format  |  Description  |
|----------|---------------|
|  u32:1-10  |  Number of times AS is allowed in path  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Accept route that contains the local-as in the as-path

`,
							},

							"attribute_unchanged": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"as_path": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send AS path unchanged

`,
									},

									"med": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send multi-exit discriminator unchanged

`,
									},

									"next_hop": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Send nexthop unchanged

`,
									},
								},
								Optional: true,
								MarkdownDescription: `BGP attributes are sent unchanged

`,
							},

							"nexthop_self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"force": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Set the next hop to self for reflected routes

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Disable the next hop calculation for this peer

`,
							},

							"route_map": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"export": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter outgoing route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},

									"import": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Route-map to filter incoming route updates

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Route map name  |
`,
									},
								},
								Optional: true,
								MarkdownDescription: `Route-map to filter route updates to/from this peer

`,
							},

							"soft_reconfiguration": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"inbound": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Enable inbound soft reconfiguration

`,
									},
								},
								Optional: true,
								MarkdownDescription: `Soft reconfiguration for peer

`,
							},
						},
						Optional: true,
						MarkdownDescription: `L2VPN EVPN BGP settings

`,
					},
				},
				Optional: true,
				MarkdownDescription: `Address-family parameters

`,
			},

			"bfd": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"profile": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Use settings from BFD profile

|  Format  |  Description  |
|----------|---------------|
|  txt  |  BFD profile name  |
`,
					},

					"check_control_plane_failure": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Allow to write CBIT independence in BFD outgoing packets and read both C-BIT value of BFD and lookup BGP peer status

`,
					},
				},
				Optional: true,
				MarkdownDescription: `Enable Bidirectional Forwarding Detection (BFD) support

`,
			},

			"capability": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"dynamic": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Advertise dynamic capability to this neighbor

`,
					},

					"extended_nexthop": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Advertise extended-nexthop capability to this neighbor

`,
					},
				},
				Optional: true,
				MarkdownDescription: `Advertise capabilities to this peer-group

`,
			},

			"ttl_security": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"hops": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Number of the maximum number of hops to the BGP peer

|  Format  |  Description  |
|----------|---------------|
|  u32:1-254  |  Number of hops  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Ttl security mechanism

`,
			},
		},
	}
}

// Create method to define the logic which creates the resource and sets its initial Terraform state.
func (r *protocols_bgp_peer_group) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *protocols_bgp_peer_groupModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create example, got error: %s", err))
	//     return
	// }

	// For the purposes of this example code, hardcoding a response value to
	// save into the Terraform state.
	data.ID = types.StringValue("example-id")

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read method to define the logic which refreshes the Terraform state for the resource.
func (r *protocols_bgp_peer_group) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *protocols_bgp_peer_groupModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
func (r *protocols_bgp_peer_group) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *protocols_bgp_peer_groupModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
func (r *protocols_bgp_peer_group) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *protocols_bgp_peer_groupModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }
}
