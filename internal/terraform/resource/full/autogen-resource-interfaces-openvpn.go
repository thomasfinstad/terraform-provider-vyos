// Code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.

package resourcefull

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/thomasfinstad/terraform-provider-vyos/internal/client"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/helpers"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &interfaces_openvpn{}

// var _ resource.ResourceWithImportState = &interfaces_openvpn{}

// interfaces_openvpn defines the resource implementation.
type interfaces_openvpn struct {
	ResourceName string
	client       *client.Client
}

func (r *interfaces_openvpn) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

// interfaces_openvpnModel describes the resource data model.
type interfaces_openvpnModel struct {
	ID types.String `tfsdk:"identifier"`

	// LeafNodes
	Description         types.String `tfsdk:"description"`
	Device_type         types.String `tfsdk:"device_type"`
	Disable             types.String `tfsdk:"disable"`
	Hash                types.String `tfsdk:"hash"`
	Local_host          types.String `tfsdk:"local_host"`
	Local_port          types.String `tfsdk:"local_port"`
	Mode                types.String `tfsdk:"mode"`
	Openvpn_option      types.String `tfsdk:"openvpn_option"`
	Persistent_tunnel   types.String `tfsdk:"persistent_tunnel"`
	Protocol            types.String `tfsdk:"protocol"`
	Remote_address      types.String `tfsdk:"remote_address"`
	Remote_host         types.String `tfsdk:"remote_host"`
	Remote_port         types.String `tfsdk:"remote_port"`
	Shared_secret_key   types.String `tfsdk:"shared_secret_key"`
	Use_lzo_compression types.String `tfsdk:"use_lzo_compression"`
	Redirect            types.String `tfsdk:"redirect"`
	Vrf                 types.String `tfsdk:"vrf"`

	// TagNodes
	Local_address types.Map `tfsdk:"local_address"`

	// Nodes
	Authentication        types.List `tfsdk:"authentication"`
	Encryption            types.List `tfsdk:"encryption"`
	Ip                    types.List `tfsdk:"ip"`
	Ipvsix                types.List `tfsdk:"ipv6"`
	Mirror                types.List `tfsdk:"mirror"`
	Keep_alive            types.List `tfsdk:"keep_alive"`
	Replace_default_route types.List `tfsdk:"replace_default_route"`
	Server                types.List `tfsdk:"server"`
	Tls                   types.List `tfsdk:"tls"`
}

func (m interfaces_openvpnModel) GetValues() (vyosPath []string, values map[string]attr.Value) {

	vyosPath = []string{
		"interfaces",
		"openvpn",

		m.ID.ValueString(),
	}

	values = map[string]attr.Value{

		// LeafNodes
		"description":         m.Description,
		"device_type":         m.Device_type,
		"disable":             m.Disable,
		"hash":                m.Hash,
		"local_host":          m.Local_host,
		"local_port":          m.Local_port,
		"mode":                m.Mode,
		"openvpn_option":      m.Openvpn_option,
		"persistent_tunnel":   m.Persistent_tunnel,
		"protocol":            m.Protocol,
		"remote_address":      m.Remote_address,
		"remote_host":         m.Remote_host,
		"remote_port":         m.Remote_port,
		"shared_secret_key":   m.Shared_secret_key,
		"use_lzo_compression": m.Use_lzo_compression,
		"redirect":            m.Redirect,
		"vrf":                 m.Vrf,

		// TagNodes
		"local_address": m.Local_address,

		// Nodes
		"authentication":        m.Authentication,
		"encryption":            m.Encryption,
		"ip":                    m.Ip,
		"ipv6":                  m.Ipvsix,
		"mirror":                m.Mirror,
		"keep_alive":            m.Keep_alive,
		"replace_default_route": m.Replace_default_route,
		"server":                m.Server,
		"tls":                   m.Tls,
	}

	return vyosPath, values
}

// Metadata method to define the resource type name.
func (r interfaces_openvpn) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	r.ResourceName = req.ProviderTypeName + "_interfaces_openvpn"
	resp.TypeName = r.ResourceName
}

// interfaces_openvpnResource method to return the example resource reference
func interfaces_openvpnResource() resource.Resource {
	return &interfaces_openvpn{}
}

// Schema method to define the schema for any resource configuration, plan, and state data.
func (r interfaces_openvpn) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: ``,

		Attributes: map[string]schema.Attribute{
			"identifier": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `OpenVPN Tunnel Interface

|  Format  |  Description  |
|----------|---------------|
|  vtunN  |  OpenVPN interface name  |
`,
			},

			"local_address": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{

						"subnet_mask": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Subnet-mask for local IP address of tunnel (IPv4 only)

`,
						},
					},
				},
				Optional: true,
				MarkdownDescription: `Local IP address of tunnel (IPv4 or IPv6)

`,
			},

			"description": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |
`,
			},

			"device_type": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `OpenVPN interface device-type

|  Format  |  Description  |
|----------|---------------|
|  tun  |  TUN device, required for OSI layer 3  |
|  tap  |  TAP device, required for OSI layer 2  |
`,

				Default:  stringdefault.StaticString(`tun`),
				Computed: true,
			},

			"disable": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Administratively disable interface

`,
			},

			"hash": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Hashing Algorithm

|  Format  |  Description  |
|----------|---------------|
|  md5  |  MD5 algorithm  |
|  sha1  |  SHA-1 algorithm  |
|  sha256  |  SHA-256 algorithm  |
|  sha384  |  SHA-384 algorithm  |
|  sha512  |  SHA-512 algorithm  |
`,
			},

			"local_host": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Local IP address to accept connections (all if not set)

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Local IPv4 address  |
|  ipv6  |  Local IPv6 address  |
`,
			},

			"local_port": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Local port number to accept connections

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Numeric IP port  |
`,
			},

			"mode": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `OpenVPN mode of operation

|  Format  |  Description  |
|----------|---------------|
|  site-to-site  |  Site-to-site mode  |
|  client  |  Client in client-server mode  |
|  server  |  Server in client-server mode  |
`,
			},

			"openvpn_option": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Additional OpenVPN options. You must use the syntax of openvpn.conf in this text-field. Using this without proper knowledge may result in a crashed OpenVPN server. Check system log to look for errors.

`,
			},

			"persistent_tunnel": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Do not close and reopen interface (TUN/TAP device) on client restarts

`,
			},

			"protocol": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `OpenVPN communication protocol

|  Format  |  Description  |
|----------|---------------|
|  udp  |  UDP  |
|  tcp-passive  |  TCP and accepts connections passively  |
|  tcp-active  |  TCP and initiates connections actively  |
`,

				Default:  stringdefault.StaticString(`udp`),
				Computed: true,
			},

			"remote_address": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `IP address of remote end of tunnel

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Remote end IPv4 address  |
|  ipv6  |  Remote end IPv6 address  |
`,
			},

			"remote_host": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Remote host to connect to (dynamic if not set)

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address of remote host  |
|  ipv6  |  IPv6 address of remote host  |
|  txt  |  Hostname of remote host  |
`,
			},

			"remote_port": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Remote port number to connect to

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Numeric IP port  |
`,
			},

			"shared_secret_key": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Secret key shared with remote end of tunnel

`,
			},

			"use_lzo_compression": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Use fast LZO compression on this TUN/TAP interface

`,
			},

			"redirect": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Redirect incoming packet to destination

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Destination interface name  |
`,
			},

			"vrf": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `VRF instance name

|  Format  |  Description  |
|----------|---------------|
|  txt  |  VRF instance name  |
`,
			},

			"authentication": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"username": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Username used for authentication

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Username  |
`,
					},

					"password": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Password used for authentication

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Password  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Authentication settings

`,
			},

			"encryption": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"cipher": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Standard Data Encryption Algorithm

|  Format  |  Description  |
|----------|---------------|
|  none  |  Disable encryption  |
|  des  |  DES algorithm  |
|  3des  |  DES algorithm with triple encryption  |
|  bf128  |  Blowfish algorithm with 128-bit key  |
|  bf256  |  Blowfish algorithm with 256-bit key  |
|  aes128  |  AES algorithm with 128-bit key CBC  |
|  aes128gcm  |  AES algorithm with 128-bit key GCM  |
|  aes192  |  AES algorithm with 192-bit key CBC  |
|  aes192gcm  |  AES algorithm with 192-bit key GCM  |
|  aes256  |  AES algorithm with 256-bit key CBC  |
|  aes256gcm  |  AES algorithm with 256-bit key GCM  |
`,
					},

					"ncp_ciphers": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Cipher negotiation list for use in server or client mode

|  Format  |  Description  |
|----------|---------------|
|  none  |  Disable encryption  |
|  des  |  DES algorithm  |
|  3des  |  DES algorithm with triple encryption  |
|  aes128  |  AES algorithm with 128-bit key CBC  |
|  aes128gcm  |  AES algorithm with 128-bit key GCM  |
|  aes192  |  AES algorithm with 192-bit key CBC  |
|  aes192gcm  |  AES algorithm with 192-bit key GCM  |
|  aes256  |  AES algorithm with 256-bit key CBC  |
|  aes256gcm  |  AES algorithm with 256-bit key GCM  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Data Encryption settings

`,
			},

			"ip": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"adjust_mss": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Adjust TCP MSS value

|  Format  |  Description  |
|----------|---------------|
|  clamp-mss-to-pmtu  |  Automatically sets the MSS to the proper value  |
|  u32:536-65535  |  TCP Maximum segment size in bytes  |
`,
					},

					"arp_cache_timeout": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `ARP cache entry timeout in seconds

|  Format  |  Description  |
|----------|---------------|
|  u32:1-86400  |  ARP cache entry timout in seconds  |
`,

						Default:  stringdefault.StaticString(`30`),
						Computed: true,
					},

					"disable_arp_filter": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Disable ARP filter on this interface

`,
					},

					"disable_forwarding": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Disable IP forwarding on this interface

`,
					},

					"enable_directed_broadcast": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable directed broadcast forwarding on this interface

`,
					},

					"enable_arp_accept": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable ARP accept on this interface

`,
					},

					"enable_arp_announce": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable ARP announce on this interface

`,
					},

					"enable_arp_ignore": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable ARP ignore on this interface

`,
					},

					"enable_proxy_arp": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable proxy-arp on this interface

`,
					},

					"proxy_arp_pvlan": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Enable private VLAN proxy ARP on this interface

`,
					},

					"source_validation": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Source validation by reversed path (RFC3704)

|  Format  |  Description  |
|----------|---------------|
|  strict  |  Enable Strict Reverse Path Forwarding as defined in RFC3704  |
|  loose  |  Enable Loose Reverse Path Forwarding as defined in RFC3704  |
|  disable  |  No source validation  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `IPv4 routing parameters

`,
			},

			"ipv6": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"adjust_mss": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Adjust TCP MSS value

|  Format  |  Description  |
|----------|---------------|
|  clamp-mss-to-pmtu  |  Automatically sets the MSS to the proper value  |
|  u32:536-65535  |  TCP Maximum segment size in bytes  |
`,
					},

					"disable_forwarding": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Disable IP forwarding on this interface

`,
					},

					"dup_addr_detect_transmits": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Number of NS messages to send while performing DAD (default: 1)

|  Format  |  Description  |
|----------|---------------|
|  u32:0  |  Disable Duplicate Address Dectection (DAD)  |
|  u32:1-n  |  Number of NS messages to send while performing DAD  |
`,
					},

					"address": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"autoconf": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Enable acquisition of IPv6 address using stateless autoconfig (SLAAC)

`,
							},

							"eui64": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Prefix for IPv6 address with MAC-based EUI-64

|  Format  |  Description  |
|----------|---------------|
|  <h:h:h:h:h:h:h:h/64>  |  IPv6 /64 network  |
`,
							},

							"no_default_link_local": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Remove the default link-local address from the interface

`,
							},
						},
						Optional: true,
						MarkdownDescription: `IPv6 address configuration modes

`,
					},
				},
				Optional: true,
				MarkdownDescription: `IPv6 routing parameters

`,
			},

			"mirror": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"ingress": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Mirror ingress traffic to destination interface

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Destination interface name  |
`,
					},

					"egress": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Mirror egress traffic to destination interface

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Destination interface name  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Mirror ingress/egress packets

`,
			},

			"keep_alive": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"failure_count": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Maximum number of keepalive packet failures

|  Format  |  Description  |
|----------|---------------|
|  u32:0-1000  |  Maximum number of keepalive packet failures  |
`,

						Default:  stringdefault.StaticString(`60`),
						Computed: true,
					},

					"interval": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Keepalive packet interval in seconds

|  Format  |  Description  |
|----------|---------------|
|  u32:0-600  |  Keepalive packet interval (seconds)  |
`,

						Default:  stringdefault.StaticString(`10`),
						Computed: true,
					},
				},
				Optional: true,
				MarkdownDescription: `Keepalive helper options

`,
			},

			"replace_default_route": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"local": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Tunnel endpoints are on the same subnet

`,
					},
				},
				Optional: true,
				MarkdownDescription: `OpenVPN tunnel to be used as the default route

`,
			},

			"server": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"client": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{

								"disable": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Disable instance

`,
								},

								"ip": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `IP address of the client

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Client IPv4 address  |
|  ipv6  |  Client IPv6 address  |
`,
								},

								"push_route": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Route to be pushed to the client

|  Format  |  Description  |
|----------|---------------|
|  ipv4net  |  IPv4 network and prefix length  |
|  ipv6net  |  IPv6 network and prefix length  |
`,
								},

								"subnet": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Subnet belonging to the client (iroute)

|  Format  |  Description  |
|----------|---------------|
|  ipv4net  |  IPv4 network and prefix length belonging to the client  |
|  ipv6net  |  IPv6 network and prefix length belonging to the client  |
`,
								},
							},
						},
						Optional: true,
						MarkdownDescription: `Client-specific settings

|  Format  |  Description  |
|----------|---------------|
|  name  |  Client common-name in the certificate  |
`,
					},

					"push_route": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{

								"metric": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Set metric for this route

|  Format  |  Description  |
|----------|---------------|
|  u32:0-4294967295  |  Metric for this route  |
`,

									Default:  stringdefault.StaticString(`0`),
									Computed: true,
								},
							},
						},
						Optional: true,
						MarkdownDescription: `Route to be pushed to all clients

|  Format  |  Description  |
|----------|---------------|
|  ipv4net  |  IPv4 network and prefix length  |
|  ipv6net  |  IPv6 network and prefix length  |
`,
					},

					"domain_name": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `DNS suffix to be pushed to all clients

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Domain Name Server suffix  |
`,
					},

					"max_connections": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Number of maximum client connections

|  Format  |  Description  |
|----------|---------------|
|  u32:1-4096  |  Number of concurrent clients  |
`,
					},

					"name_server": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Domain Name Servers (DNS) addresses

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  Domain Name Server (DNS) IPv4 address  |
|  ipv6  |  Domain Name Server (DNS) IPv6 address  |
`,
					},

					"reject_unconfigured_clients": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Reject connections from clients that are not explicitly configured

`,
					},

					"subnet": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Server-mode subnet (from which client IPs are allocated)

|  Format  |  Description  |
|----------|---------------|
|  ipv4net  |  IPv4 network and prefix length  |
|  ipv6net  |  IPv6 network and prefix length  |
`,
					},

					"topology": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Topology for clients

|  Format  |  Description  |
|----------|---------------|
|  net30  |  net30 topology  |
|  point-to-point  |  Point-to-point topology  |
|  subnet  |  Subnet topology  |
`,

						Default:  stringdefault.StaticString(`net30`),
						Computed: true,
					},

					"client_ip_pool": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"disable": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Disable instance

`,
							},

							"start": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `First IP address in the pool

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address  |
`,
							},

							"stop": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Last IP address in the pool

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address  |
`,
							},

							"subnet_mask": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Subnet mask pushed to dynamic clients. If not set the server subnet mask will be used. Only used with topology subnet or device type tap. Not used with bridged interfaces.

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 subnet mask  |
`,
							},
						},
						Optional: true,
						MarkdownDescription: `Pool of client IPv4 addresses

`,
					},

					"client_ipv6_pool": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"base": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Client IPv6 pool base address with optional prefix length

|  Format  |  Description  |
|----------|---------------|
|  ipv6net  |  Client IPv6 pool base address with optional prefix length (defaults: base = server subnet + 0x1000, prefix length = server prefix length)  |
`,
							},

							"disable": schema.StringAttribute{

								Optional: true,
								MarkdownDescription: `Disable instance

`,
							},
						},
						Optional: true,
						MarkdownDescription: `Pool of client IPv6 addresses

`,
					},

					"mfa": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{

							"totp": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{

									"slop": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Maximum allowed clock slop in seconds

|  Format  |  Description  |
|----------|---------------|
|  1-65535  |  Seconds  |
`,

										Default:  stringdefault.StaticString(`180`),
										Computed: true,
									},

									"drift": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Time drift in seconds

|  Format  |  Description  |
|----------|---------------|
|  1-65535  |  Seconds  |
`,

										Default:  stringdefault.StaticString(`0`),
										Computed: true,
									},

									"step": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Step value for totp in seconds

|  Format  |  Description  |
|----------|---------------|
|  1-65535  |  Seconds  |
`,

										Default:  stringdefault.StaticString(`30`),
										Computed: true,
									},

									"digits": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Number of digits to use for totp hash

|  Format  |  Description  |
|----------|---------------|
|  1-65535  |  Seconds  |
`,

										Default:  stringdefault.StaticString(`6`),
										Computed: true,
									},

									"challenge": schema.StringAttribute{

										Optional: true,
										MarkdownDescription: `Expect password as result of a challenge response protocol

|  Format  |  Description  |
|----------|---------------|
|  disable  |  Disable challenge-response  |
|  enable  |  Enable chalenge-response  |
`,

										Default:  stringdefault.StaticString(`enable`),
										Computed: true,
									},
								},
								Optional: true,
								MarkdownDescription: `Time-based one-time passwords

`,
							},
						},
						Optional: true,
						MarkdownDescription: `multi-factor authentication

`,
					},
				},
				Optional: true,
				MarkdownDescription: `Server-mode options

`,
			},

			"tls": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{

					"auth_key": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `TLS shared secret key for tls-auth

`,
					},

					"certificate": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Certificate in PKI configuration

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of certificate in PKI configuration  |
`,
					},

					"ca_certificate": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Certificate Authority chain in PKI configuration

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of CA in PKI configuration  |
`,
					},

					"dh_params": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Diffie Hellman parameters (server only)

`,
					},

					"crypt_key": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Static key to use to authenticate control channel

`,
					},

					"tls_version_min": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `Specify the minimum required TLS version

|  Format  |  Description  |
|----------|---------------|
|  1.0  |  TLS v1.0  |
|  1.1  |  TLS v1.1  |
|  1.2  |  TLS v1.2  |
|  1.3  |  TLS v1.3  |
`,
					},

					"role": schema.StringAttribute{

						Optional: true,
						MarkdownDescription: `TLS negotiation role

|  Format  |  Description  |
|----------|---------------|
|  active  |  Initiate TLS negotiation actively  |
|  passive  |  Wait for incoming TLS connection  |
`,
					},
				},
				Optional: true,
				MarkdownDescription: `Transport Layer Security (TLS) options

`,
			},
		},
	}
}

// Create method to define the logic which creates the resource and sets its initial Terraform state.
func (r interfaces_openvpn) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	ctx = context.WithValue(ctx, "crud_func", "Create")

	var data *firewall_nameModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create vyos api ops
	vyosOps := helpers.FromTerraformToVyos(ctx, data)
	for _, ops := range vyosOps {
		tflog.Error(ctx, "Vyos Ops generated", map[string]interface{}{"vyosOps": ops})
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	r.client.StageSet(ctx, vyosOps)
	response, err := r.client.CommitChanges(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
		return
	}
	if response != nil {
		tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
	}

	// Save ID into the Terraform state.
	data.ID = types.StringValue(data.ID.ValueString())

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read method to define the logic which refreshes the Terraform state for the resource.
func (r interfaces_openvpn) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *interfaces_openvpnModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
func (r interfaces_openvpn) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *interfaces_openvpnModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
func (r interfaces_openvpn) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *interfaces_openvpnModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }
}
