// Code generated by /workspaces/terraform-provider-vyos/tools/build-terraform-resource-full/main.go. DO NOT EDIT.

package resourcefull

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/thomasfinstad/terraform-provider-vyos/internal/client"
	"github.com/thomasfinstad/terraform-provider-vyos/internal/terraform/helpers"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &firewall_ipvsix_name{}

// var _ resource.ResourceWithImportState = &firewall_ipvsix_name{}

// firewall_ipvsix_name defines the resource implementation.
type firewall_ipvsix_name struct {
	ResourceName string
	client       *client.Client
}

func (r *firewall_ipvsix_name) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

// firewall_ipvsix_nameModel describes the resource data model.
type firewall_ipvsix_nameModel struct {
	ID types.String `tfsdk:"identifier"`

	// LeafNodes
	Default_action      types.String `tfsdk:"default_action"`
	Enable_default_log  types.String `tfsdk:"enable_default_log"`
	Description         types.String `tfsdk:"description"`
	Default_jump_target types.String `tfsdk:"default_jump_target"`

	// TagNodes
	Rule types.Map `tfsdk:"rule"`

	// Nodes

}

func (m firewall_ipvsix_nameModel) GetValues() (vyosPath []string, values map[string]attr.Value) {

	vyosPath = []string{
		"firewall",
		"ipv6-name",

		m.ID.ValueString(),
	}

	values = map[string]attr.Value{

		// LeafNodes
		"default_action":      m.Default_action,
		"enable_default_log":  m.Enable_default_log,
		"description":         m.Description,
		"default_jump_target": m.Default_jump_target,

		// TagNodes
		"rule": m.Rule,

		// Nodes

	}

	return vyosPath, values
}

// Metadata method to define the resource type name.
func (r firewall_ipvsix_name) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	r.ResourceName = req.ProviderTypeName + "_firewall_ipv6_name"
	resp.TypeName = r.ResourceName
}

// firewall_ipvsix_nameResource method to return the example resource reference
func firewall_ipvsix_nameResource() resource.Resource {
	return &firewall_ipvsix_name{}
}

// Schema method to define the schema for any resource configuration, plan, and state data.
func (r firewall_ipvsix_name) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: `Firewall

`,

		Attributes: map[string]schema.Attribute{
			"identifier": schema.StringAttribute{
				Required: true,
				MarkdownDescription: `IPv6 firewall rule-set name

`,
			},

			"rule": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{

						"action": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Rule action

|  Format  |  Description  |
|----------|---------------|
|  accept  |  Accept matching entries  |
|  jump  |  Jump to another chain  |
|  reject  |  Reject matching entries  |
|  return  |  Return from the current chain and continue at the next rule of the
                      last chain  |
|  drop  |  Drop matching entries  |
|  queue  |  Enqueue packet to userspace  |
`,
						},

						"description": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |
`,
						},

						"disable": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Option to disable firewall rule

`,
						},

						"log": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Option to log packets matching rule

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable log  |
|  disable  |  Disable log  |
`,
						},

						"log_level": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Set log-level. Log must be enable.

|  Format  |  Description  |
|----------|---------------|
|  emerg  |  Emerg log level  |
|  alert  |  Alert log level  |
|  crit  |  Critical log level  |
|  err  |  Error log level  |
|  warn  |  Warning log level  |
|  notice  |  Notice log level  |
|  info  |  Info log level  |
|  debug  |  Debug log level  |
`,
						},

						"protocol": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Protocol to match (protocol name, number, or "all")

|  Format  |  Description  |
|----------|---------------|
|  all  |  All IP protocols  |
|  tcp_udp  |  Both TCP and UDP  |
|  u32:0-255  |  IP protocol number  |
|  <protocol>  |  IP protocol name  |
|  !<protocol>  |  IP protocol name  |
`,
						},

						"dscp": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `DSCP value

|  Format  |  Description  |
|----------|---------------|
|  u32:0-63  |  DSCP value to match  |
|  <start-end>  |  DSCP range to match  |
`,
						},

						"dscp_exclude": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `DSCP value not to match

|  Format  |  Description  |
|----------|---------------|
|  u32:0-63  |  DSCP value not to match  |
|  <start-end>  |  DSCP range not to match  |
`,
						},

						"packet_length": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Payload size in bytes, including header and data to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Packet length to match  |
|  <start-end>  |  Packet length range to match  |
`,
						},

						"packet_length_exclude": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Payload size in bytes, including header and data not to match

|  Format  |  Description  |
|----------|---------------|
|  u32:1-65535  |  Packet length not to match  |
|  <start-end>  |  Packet length range not to match  |
`,
						},

						"packet_type": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Packet type

|  Format  |  Description  |
|----------|---------------|
|  broadcast  |  Match broadcast packet type  |
|  host  |  Match host packet type, addressed to local host  |
|  multicast  |  Match multicast packet type  |
|  other  |  Match packet addressed to another host  |
`,
						},

						"connection_mark": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Connection mark

|  Format  |  Description  |
|----------|---------------|
|  u32:0-2147483647  |  Connection-mark to match  |
`,
						},

						"jump_target": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Set jump target. Action jump must be defined to use this setting

`,
						},

						"queue": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Queue target to use. Action queue must be defined to use this setting

|  Format  |  Description  |
|----------|---------------|
|  u32:0-65535  |  Queue target  |
`,
						},

						"queue_options": schema.StringAttribute{

							Optional: true,
							MarkdownDescription: `Options used for queue target. Action queue must be defined to use this
                    setting

|  Format  |  Description  |
|----------|---------------|
|  bypass  |  Let packets go through if userspace application cannot back off  |
|  fanout  |  Distribute packets between several queues  |
`,
						},

						"destination": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"mac_address": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `MAC address

|  Format  |  Description  |
|----------|---------------|
|  macaddr  |  MAC address to match  |
|  !macaddr  |  Match everything except the specified MAC address  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Destination parameters

`,
						},

						"fragment": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"match_frag": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Second and further fragments of fragmented packets

`,
								},

								"match_non_frag": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Head fragments or unfragmented packets

`,
								},
							},
							Optional: true,
							MarkdownDescription: `IP fragment match

`,
						},

						"inbound_interface": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"interface_name": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match interface

`,
								},

								"interface_group": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match interface-group

`,
								},
							},
							Optional: true,
							MarkdownDescription: `Match inbound-interface

`,
						},

						"outbound_interface": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"interface_name": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match interface

`,
								},

								"interface_group": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match interface-group

`,
								},
							},
							Optional: true,
							MarkdownDescription: `Match outbound-interface

`,
						},

						"ipsec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"match_ipsec": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Inbound IPsec packets

`,
								},

								"match_none": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Inbound non-IPsec packets

`,
								},
							},
							Optional: true,
							MarkdownDescription: `Inbound IPsec packets

`,
						},

						"limit": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"burst": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Maximum number of packets to allow in excess of rate

|  Format  |  Description  |
|----------|---------------|
|  u32:0-4294967295  |  Maximum number of packets to allow in excess of rate  |
`,
								},

								"rate": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Maximum average matching rate

|  Format  |  Description  |
|----------|---------------|
|  txt  |  integer/unit (Example: 5/minute)  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Rate limit using a token bucket filter

`,
						},

						"connection_status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"nat": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `NAT connection status

|  Format  |  Description  |
|----------|---------------|
|  destination  |  Match connections that are subject to destination NAT  |
|  source  |  Match connections that are subject to source NAT  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Connection status

`,
						},

						"recent": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"count": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Source addresses seen more than N times

|  Format  |  Description  |
|----------|---------------|
|  u32:1-255  |  Source addresses seen more than N times  |
`,
								},

								"time": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Source addresses seen in the last second/minute/hour

|  Format  |  Description  |
|----------|---------------|
|  second  |  Source addresses seen COUNT times in the last second  |
|  minute  |  Source addresses seen COUNT times in the last minute  |
|  hour  |  Source addresses seen COUNT times in the last hour  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Parameters for matching recently seen sources

`,
						},

						"source": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"address": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `IP address, subnet, or range

|  Format  |  Description  |
|----------|---------------|
|  ipv4  |  IPv4 address to match  |
|  ipv4net  |  IPv4 prefix to match  |
|  ipv4range  |  IPv4 address range to match  |
|  !ipv4  |  Match everything except the specified address  |
|  !ipv4net  |  Match everything except the specified prefix  |
|  !ipv4range  |  Match everything except the specified range  |
`,
								},

								"mac_address": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `MAC address

|  Format  |  Description  |
|----------|---------------|
|  macaddr  |  MAC address to match  |
|  !macaddr  |  Match everything except the specified MAC address  |
`,
								},

								"port": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Port

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Named port (any name in /etc/services, e.g., http)  |
|  u32:1-65535  |  Numbered port  |
|  <start-end>  |  Numbered port range (e.g. 1001-1005)  |
|     |  \n\n Multiple destination ports can be specified as a
                          comma-separated list.\n For example: 'telnet,http,123,1001-1005'  |
`,
								},

								"group": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{

										"address_group": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Group of addresses

`,
										},

										"domain_group": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Group of domains

`,
										},

										"mac_group": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Group of MAC addresses

`,
										},

										"network_group": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Group of networks

`,
										},

										"port_group": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Group of ports

`,
										},
									},
									Optional: true,
									MarkdownDescription: `Group

`,
								},
							},
							Optional: true,
							MarkdownDescription: `Source parameters

`,
						},

						"state": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"established": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Established state

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable  |
|  disable  |  Disable  |
`,
								},

								"invalid": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Invalid state

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable  |
|  disable  |  Disable  |
`,
								},

								"new": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `New state

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable  |
|  disable  |  Disable  |
`,
								},

								"related": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Related state

|  Format  |  Description  |
|----------|---------------|
|  enable  |  Enable  |
|  disable  |  Disable  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Session state

`,
						},

						"tcp": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"mss": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Maximum segment size (MSS)

|  Format  |  Description  |
|----------|---------------|
|  u32:1-16384  |  Maximum segment size  |
|  <min>-<max>  |  TCP MSS range (use '-' as delimiter)  |
`,
								},

								"flags": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{

										"syn": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Synchronise flag

`,
										},

										"ack": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Acknowledge flag

`,
										},

										"fin": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Finish flag

`,
										},

										"rst": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Reset flag

`,
										},

										"urg": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Urgent flag

`,
										},

										"psh": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Push flag

`,
										},

										"ecn": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Explicit Congestion Notification flag

`,
										},

										"cwr": schema.StringAttribute{

											Optional: true,
											MarkdownDescription: `Congestion Window Reduced flag

`,
										},

										"not": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{

												"syn": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Synchronise flag

`,
												},

												"ack": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Acknowledge flag

`,
												},

												"fin": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Finish flag

`,
												},

												"rst": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Reset flag

`,
												},

												"urg": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Urgent flag

`,
												},

												"psh": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Push flag

`,
												},

												"ecn": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Explicit Congestion Notification flag

`,
												},

												"cwr": schema.StringAttribute{

													Optional: true,
													MarkdownDescription: `Congestion Window Reduced flag

`,
												},
											},
											Optional: true,
											MarkdownDescription: `Match flags not set

`,
										},
									},
									Optional: true,
									MarkdownDescription: `TCP flags to match

`,
								},
							},
							Optional: true,
							MarkdownDescription: `TCP flags to match

`,
						},

						"time": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"startdate": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Date to start matching rule

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Enter date using following notation - YYYY-MM-DD  |
`,
								},

								"starttime": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Time of day to start matching rule

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Enter time using using 24 hour notation - hh:mm:ss  |
`,
								},

								"stopdate": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Date to stop matching rule

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Enter date using following notation - YYYY-MM-DD  |
`,
								},

								"stoptime": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Time of day to stop matching rule

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Enter time using using 24 hour notation - hh:mm:ss  |
`,
								},

								"weekdays": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Comma separated weekdays to match rule on

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Name of day (Monday, Tuesday, Wednesday, Thursdays, Friday,
                          Saturday, Sunday)  |
|  u32:0-6  |  Day number (0 = Sunday ... 6 = Saturday)  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Time to match rule

`,
						},

						"hop_limit": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"eq": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match on equal value

|  Format  |  Description  |
|----------|---------------|
|  u32:0-255  |  Equal to value  |
`,
								},

								"gt": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match on greater then value

|  Format  |  Description  |
|----------|---------------|
|  u32:0-255  |  Greater then value  |
`,
								},

								"lt": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `Match on less then value

|  Format  |  Description  |
|----------|---------------|
|  u32:0-255  |  Less then value  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `Hop limit

`,
						},

						"icmpv6": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{

								"code": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `ICMPv6 code

|  Format  |  Description  |
|----------|---------------|
|  u32:0-255  |  ICMPv6 code (0-255)  |
`,
								},

								"type": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `ICMPv6 type

|  Format  |  Description  |
|----------|---------------|
|  u32:0-255  |  ICMPv6 type (0-255)  |
`,
								},

								"type_name": schema.StringAttribute{

									Optional: true,
									MarkdownDescription: `ICMPv6 type-name

|  Format  |  Description  |
|----------|---------------|
|  destination-unreachable  |  ICMPv6 type 1: destination-unreachable  |
|  packet-too-big  |  ICMPv6 type 2: packet-too-big  |
|  time-exceeded  |  ICMPv6 type 3: time-exceeded  |
|  echo-request  |  ICMPv6 type 128: echo-request  |
|  echo-reply  |  ICMPv6 type 129: echo-reply  |
|  mld-listener-query  |  ICMPv6 type 130: mld-listener-query  |
|  mld-listener-report  |  ICMPv6 type 131: mld-listener-report  |
|  mld-listener-reduction  |  ICMPv6 type 132: mld-listener-reduction  |
|  nd-router-solicit  |  ICMPv6 type 133: nd-router-solicit  |
|  nd-router-advert  |  ICMPv6 type 134: nd-router-advert  |
|  nd-neighbor-solicit  |  ICMPv6 type 135: nd-neighbor-solicit  |
|  nd-neighbor-advert  |  ICMPv6 type 136: nd-neighbor-advert  |
|  nd-redirect  |  ICMPv6 type 137: nd-redirect  |
|  parameter-problem  |  ICMPv6 type 4: parameter-problem  |
|  router-renumbering  |  ICMPv6 type 138: router-renumbering  |
|  ind-neighbor-solicit  |  ICMPv6 type 141: ind-neighbor-solicit  |
|  ind-neighbor-advert  |  ICMPv6 type 142: ind-neighbor-advert  |
|  mld2-listener-report  |  ICMPv6 type 143: mld2-listener-report  |
`,
								},
							},
							Optional: true,
							MarkdownDescription: `ICMPv6 type and code information

`,
						},
					},
				},
				Optional: true,
				MarkdownDescription: `Firewall rule number (IPv6)

|  Format  |  Description  |
|----------|---------------|
|  u32:1-999999  |  Number for this Firewall rule  |
`,
			},

			"default_action": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Default-action for rule-set

|  Format  |  Description  |
|----------|---------------|
|  drop  |  Drop if no prior rules are hit  |
|  jump  |  Jump to another chain if no prior rules are hit  |
|  reject  |  Drop and notify source if no prior rules are hit  |
|  return  |  Return from the current chain and continue at the next rule of the last
                  chain  |
|  accept  |  Accept if no prior rules are hit  |
`,

				Default:  stringdefault.StaticString(`drop`),
				Computed: true,
			},

			"enable_default_log": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Log packets hitting default-action

`,
			},

			"description": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Description

|  Format  |  Description  |
|----------|---------------|
|  txt  |  Description  |
`,
			},

			"default_jump_target": schema.StringAttribute{

				Optional: true,
				MarkdownDescription: `Set jump target. Action jump must be defined in default-action to use this
                setting

`,
			},
		},
	}
}

// Create method to define the logic which creates the resource and sets its initial Terraform state.
func (r firewall_ipvsix_name) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	ctx = context.WithValue(ctx, "crud_func", "Create")

	var data *firewall_nameModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create vyos api ops
	vyosOps := helpers.FromTerraformToVyos(ctx, data)
	for _, ops := range vyosOps {
		tflog.Error(ctx, "Vyos Ops generated", map[string]interface{}{"vyosOps": ops})
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	r.client.StageSet(ctx, vyosOps)
	response, err := r.client.CommitChanges(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create %s, got error: %s", r.ResourceName, err))
		return
	}
	if response != nil {
		tflog.Warn(ctx, "Got non-nil response from API", map[string]interface{}{"response": response})
	}

	// Save ID into the Terraform state.
	data.ID = types.StringValue(data.ID.ValueString())

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read method to define the logic which refreshes the Terraform state for the resource.
func (r firewall_ipvsix_name) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *firewall_ipvsix_nameModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Update method to define the logic which updates the resource and sets the updated Terraform state on success.
func (r firewall_ipvsix_name) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *firewall_ipvsix_nameModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete method to define the logic which deletes the resource and removes the Terraform state on success.
func (r firewall_ipvsix_name) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *firewall_ipvsix_nameModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// httpResp, err := r.client.Do(httpReq)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }
}
